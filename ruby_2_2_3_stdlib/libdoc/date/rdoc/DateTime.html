<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.33.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : DateTime  -   Ruby 2_2_3 ' />
  <meta content="2015-10-03 10:47:00 -0500" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = true-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: DateTime (Ruby 2_2_3) </title>
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >

  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'>
	<li class='grid-2' ><a href='/' target='_top' >Home</a></li>
	<li class='grid-2' ><a href='/core' target='_top' >Core </a></li>
	<li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib </a></li>

	 <!-- li class='grid-2' ><a href='/zems' target='_top' >Zems</a></li -->
   <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
	 <li class='grid-5 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.com/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input  id='rd-search-input' name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form></li>
	</ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2_2_3 NOT FOUND --></div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>date/date_core.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link"><a href="Date.html">Date</a></p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-_strptime">::_strptime</a></li>
          
          <li><a href="#method-c-civil">::civil</a></li>
          
          <li><a href="#method-c-commercial">::commercial</a></li>
          
          <li><a href="#method-c-httpdate">::httpdate</a></li>
          
          <li><a href="#method-c-iso8601">::iso8601</a></li>
          
          <li><a href="#method-c-jd">::jd</a></li>
          
          <li><a href="#method-c-jisx0301">::jisx0301</a></li>
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-now">::now</a></li>
          
          <li><a href="#method-c-ordinal">::ordinal</a></li>
          
          <li><a href="#method-c-parse">::parse</a></li>
          
          <li><a href="#method-c-rfc2822">::rfc2822</a></li>
          
          <li><a href="#method-c-rfc3339">::rfc3339</a></li>
          
          <li><a href="#method-c-rfc822">::rfc822</a></li>
          
          <li><a href="#method-c-strptime">::strptime</a></li>
          
          <li><a href="#method-c-xmlschema">::xmlschema</a></li>
          
          <li><a href="#method-i-iso8601">#iso8601</a></li>
          
          <li><a href="#method-i-jisx0301">#jisx0301</a></li>
          
          <li><a href="#method-i-rfc3339">#rfc3339</a></li>
          
          <li><a href="#method-i-strftime">#strftime</a></li>
          
          <li><a href="#method-i-to_date">#to_date</a></li>
          
          <li><a href="#method-i-to_datetime">#to_datetime</a></li>
          
          <li><a href="#method-i-to_s">#to_s</a></li>
          
          <li><a href="#method-i-to_time">#to_time</a></li>
          
          <li><a href="#method-i-xmlschema">#xmlschema</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./Date.html">Date</a></li>
        
          
          
          <li><a href="./DateTime.html">DateTime</a></li>
        
          
          
          <li><a href="./Time.html">Time</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
   <div id="carbonads-container"><div class="carbonad"><div id="azcarbon"></div><script type="text/javascript">var z = document.createElement("script"); z.type = "text/javascript"; z.async = true; z.src = "http://engine.carbonads.com/z/19647/azcarbon_2_1_0_VERT"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(z, s);</script></div></div>
<script type="text/javascript">
  function checkCarbs() {
    var searchFor = ".car" + "bona" + "d-tag";
    var ctext = $(searchFor);
    if (!ctext.length ) {
     // alert("Cannot find element with class " + searchFor );
      $("#azcarbon").append("<div class='rd-ab-msg'>If you are running an ad blocker please consider white-listing ruby-doc.org. <br><br>Thank you.</div>");
    }
  }
//  window.setTimeout(checkCarbs,3000); 
</script>

   
  </div> 
  <div id="documentation">
    <h1 class="class">DateTime</h1>

    <div id="description" class="description">
      
<p>datetime</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="_strptime-method" class="method-detail ">
          <a name="method-c-_strptime"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">_strptime(string[, format='%FT%T%z'])  &rarr;  hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Parses the given representation of date and time with the given template,
and returns a hash of parsed elements.  _strptime does not support
specification of flags and width unlike strftime.</p>

<pre>See also strptime(3) and strftime.</pre>
            

            
            <div class="method-source-code" id="_strptime-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s__strptime(int argc, VALUE *argv, VALUE klass)
{
    return date_s__strptime_internal(argc, argv, klass, &quot;%FT%T%z&quot;);
}
            </pre> 
            </div><!-- _strptime-source -->
            
          </div>

          

          
        </div><!-- _strptime-method -->
      
        <div id="civil-method" class="method-detail ">
          <a name="method-c-civil"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">civil([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a date-time object denoting the given calendar date.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>)    <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">-11</span>,<span class="ruby-value">-26</span>,<span class="ruby-value">-20</span>,<span class="ruby-value">-55</span>,<span class="ruby-value">-54</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="civil-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_civil(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vm, vd, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;
    int m, d, h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, &quot;08&quot;, &amp;vy, &amp;vm, &amp;vd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    y = INT2FIX(-4712);
    m = 1;
    d = 1;

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 8:
        val2sg(vsg, sg);
      case 7:
        val2off(vof, rof);
      case 6:
        num2int_with_frac(s, positive_inf);
      case 5:
        num2int_with_frac(min, 5);
      case 4:
        num2int_with_frac(h, 4);
      case 3:
        num2int_with_frac(d, 3);
      case 2:
        m = NUM2INT(vm);
      case 1:
        y = vy;
    }

    if (guess_style(y, sg) &lt; 0) {
        VALUE nth;
        int ry, rm, rd, rh, rmin, rs;

        if (!valid_gregorian_p(y, m, d,
                               &amp;nth, &amp;ry,
                               &amp;rm, &amp;rd))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        ret = d_complex_new_internal(klass,
                                     nth, 0,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     ry, rm, rd,
                                     rh, rmin, rs,
                                     HAVE_CIVIL | HAVE_TIME);
    }
    else {
        VALUE nth;
        int ry, rm, rd, rh, rmin, rs, rjd, rjd2, ns;

        if (!valid_civil_p(y, m, d, sg,
                           &amp;nth, &amp;ry,
                           &amp;rm, &amp;rd, &amp;rjd,
                           &amp;ns))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     ry, rm, rd,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_CIVIL | HAVE_TIME);
    }
    add_frac();
    return ret;
}
            </pre> 
            </div><!-- civil-source -->
            
          </div>

          

          
        </div><!-- civil-method -->
      
        <div id="commercial-method" class="method-detail ">
          <a name="method-c-commercial"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">commercial([cwyear=-4712[, cweek=1[, cwday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a date-time object denoting the given week date.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2001</span>) <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-01-01T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2002</span>) <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-12-31T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">commercial</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="commercial-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_commercial(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vw, vd, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;
    int w, d, h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, &quot;08&quot;, &amp;vy, &amp;vw, &amp;vd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    y = INT2FIX(-4712);
    w = 1;
    d = 1;

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 8:
        val2sg(vsg, sg);
      case 7:
        val2off(vof, rof);
      case 6:
        num2int_with_frac(s, positive_inf);
      case 5:
        num2int_with_frac(min, 5);
      case 4:
        num2int_with_frac(h, 4);
      case 3:
        num2int_with_frac(d, 3);
      case 2:
        w = NUM2INT(vw);
      case 1:
        y = vy;
    }

    {
        VALUE nth;
        int ry, rw, rd, rh, rmin, rs, rjd, rjd2, ns;

        if (!valid_commercial_p(y, w, d, sg,
                                &amp;nth, &amp;ry,
                                &amp;rw, &amp;rd, &amp;rjd,
                                &amp;ns))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     0, 0, 0,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_TIME);
    }
    add_frac();
    return ret;
}
            </pre> 
            </div><!-- commercial-source -->
            
          </div>

          

          
        </div><!-- commercial-method -->
      
        <div id="httpdate-method" class="method-detail ">
          <a name="method-c-httpdate"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">httpdate(string='Mon, 01 Jan -4712 00:00:00 GMT'[, start=ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some RFC 2616 format.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">httpdate</span>(<span class="ruby-string">'Sat, 03 Feb 2001 04:05:06 GMT'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+00:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="httpdate-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;Mon, 01 Jan -4712 00:00:00 GMT&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__httpdate(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- httpdate-source -->
            
          </div>

          

          
        </div><!-- httpdate-method -->
      
        <div id="iso8601-method" class="method-detail ">
          <a name="method-c-iso8601"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">iso8601(string='-4712-01-01T00:00:00+00:00'[, start=ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some typical ISO 8601 formats.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">iso8601</span>(<span class="ruby-string">'2001-02-03T04:05:06+07:00'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">iso8601</span>(<span class="ruby-string">'20010203T040506+0700'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">iso8601</span>(<span class="ruby-string">'2001-W05-6T04:05:06+07:00'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="iso8601-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__iso8601(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- iso8601-source -->
            
          </div>

          

          
        </div><!-- iso8601-method -->
      
        <div id="jd-method" class="method-detail ">
          <a name="method-c-jd"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">jd([jd=0[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a datetime object denoting the given chronological Julian day
number.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">2451944</span>)      <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-value">2451945</span>)      <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-04T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">jd</span>(<span class="ruby-constant">Rational</span>(<span class="ruby-string">'0.5'</span>))
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: -4712-01-01T12:00:00+00:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="jd-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_jd(int argc, VALUE *argv, VALUE klass)
{
    VALUE vjd, vh, vmin, vs, vof, vsg, jd, fr, fr2, ret;
    int h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, &quot;06&quot;, &amp;vjd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    jd = INT2FIX(0);

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 6:
        val2sg(vsg, sg);
      case 5:
        val2off(vof, rof);
      case 4:
        num2int_with_frac(s, positive_inf);
      case 3:
        num2int_with_frac(min, 3);
      case 2:
        num2int_with_frac(h, 2);
      case 1:
        num2num_with_frac(jd, 1);
    }

    {
        VALUE nth;
        int rh, rmin, rs, rjd, rjd2;

        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        decode_jd(jd, &amp;nth, &amp;rjd);
        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     0, 0, 0,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_TIME);
    }
    add_frac();
    return ret;
}
            </pre> 
            </div><!-- jd-source -->
            
          </div>

          

          
        </div><!-- jd-method -->
      
        <div id="jisx0301-method" class="method-detail ">
          <a name="method-c-jisx0301"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">jisx0301(string='-4712-01-01T00:00:00+00:00'[, start=ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some typical JIS X 0301 formats.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">jisx0301</span>(<span class="ruby-string">'H13.02.03T04:05:06+07:00'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="jisx0301-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_jisx0301(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__jisx0301(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- jisx0301-source -->
            
          </div>

          

          
        </div><!-- jisx0301-method -->
      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new([year=-4712[, month=1[, mday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]]])    &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a date-time object denoting the given calendar date.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>)    <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">-11</span>,<span class="ruby-value">-26</span>,<span class="ruby-value">-20</span>,<span class="ruby-value">-55</span>,<span class="ruby-value">-54</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_civil(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vm, vd, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;
    int m, d, h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, &quot;08&quot;, &amp;vy, &amp;vm, &amp;vd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    y = INT2FIX(-4712);
    m = 1;
    d = 1;

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 8:
        val2sg(vsg, sg);
      case 7:
        val2off(vof, rof);
      case 6:
        num2int_with_frac(s, positive_inf);
      case 5:
        num2int_with_frac(min, 5);
      case 4:
        num2int_with_frac(h, 4);
      case 3:
        num2int_with_frac(d, 3);
      case 2:
        m = NUM2INT(vm);
      case 1:
        y = vy;
    }

    if (guess_style(y, sg) &lt; 0) {
        VALUE nth;
        int ry, rm, rd, rh, rmin, rs;

        if (!valid_gregorian_p(y, m, d,
                               &amp;nth, &amp;ry,
                               &amp;rm, &amp;rd))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        ret = d_complex_new_internal(klass,
                                     nth, 0,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     ry, rm, rd,
                                     rh, rmin, rs,
                                     HAVE_CIVIL | HAVE_TIME);
    }
    else {
        VALUE nth;
        int ry, rm, rd, rh, rmin, rs, rjd, rjd2, ns;

        if (!valid_civil_p(y, m, d, sg,
                           &amp;nth, &amp;ry,
                           &amp;rm, &amp;rd, &amp;rjd,
                           &amp;ns))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     ry, rm, rd,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_CIVIL | HAVE_TIME);
    }
    add_frac();
    return ret;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="now-method" class="method-detail ">
          <a name="method-c-now"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">now([start=Date::ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a date-time object denoting the present time.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">now</span>              <span class="ruby-comment">#=&gt; #&lt;DateTime: 2011-06-11T21:20:44+09:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="now-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_now(int argc, VALUE *argv, VALUE klass)
{
    VALUE vsg, nth, ret;
    double sg;
#ifdef HAVE_CLOCK_GETTIME
    struct timespec ts;
#else
    struct timeval tv;
#endif
    time_t sec;
    struct tm tm;
    long sf, of;
    int y, ry, m, d, h, min, s;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;vsg);

    if (argc &lt; 1)
        sg = DEFAULT_SG;
    else
        sg = NUM2DBL(vsg);

#ifdef HAVE_CLOCK_GETTIME
    if (clock_gettime(CLOCK_REALTIME, &amp;ts) == -1)
        rb_sys_fail(&quot;clock_gettime&quot;);
    sec = ts.tv_sec;
#else
    if (gettimeofday(&amp;tv, NULL) == -1)
        rb_sys_fail(&quot;gettimeofday&quot;);
    sec = tv.tv_sec;
#endif
    tzset();
    if (!localtime_r(&amp;sec, &amp;tm))
        rb_sys_fail(&quot;localtime&quot;);

    y = tm.tm_year + 1900;
    m = tm.tm_mon + 1;
    d = tm.tm_mday;
    h = tm.tm_hour;
    min = tm.tm_min;
    s = tm.tm_sec;
    if (s == 60)
        s = 59;
#ifdef HAVE_STRUCT_TM_TM_GMTOFF
    of = tm.tm_gmtoff;
#elif defined(HAVE_VAR_TIMEZONE)
#ifdef HAVE_VAR_ALTZONE
    of = (long)-((tm.tm_isdst &gt; 0) ? altzone : timezone);
#else
    of = (long)-timezone;
    if (tm.tm_isdst) {
        time_t sec2;

        tm.tm_isdst = 0;
        sec2 = mktime(&amp;tm);
        of += (long)difftime(sec2, sec);
    }
#endif
#elif defined(HAVE_TIMEGM)
    {
        time_t sec2;

        sec2 = timegm(&amp;tm);
        of = (long)difftime(sec2, sec);
    }
#else
    {
        struct tm tm2;
        time_t sec2;

        if (!gmtime_r(&amp;sec, &amp;tm2))
            rb_sys_fail(&quot;gmtime&quot;);
        tm2.tm_isdst = tm.tm_isdst;
        sec2 = mktime(&amp;tm2);
        of = (long)difftime(sec, sec2);
    }
#endif
#ifdef HAVE_CLOCK_GETTIME
    sf = ts.tv_nsec;
#else
    sf = tv.tv_usec * 1000;
#endif

    if (of &lt; -DAY_IN_SECONDS || of &gt; DAY_IN_SECONDS) {
        of = 0;
        rb_warning(&quot;invalid offset is ignored&quot;);
    }

    decode_year(INT2FIX(y), -1, &amp;nth, &amp;ry);

    ret = d_complex_new_internal(klass,
                                 nth, 0,
                                 0, LONG2NUM(sf),
                                 (int)of, GREGORIAN,
                                 ry, m, d,
                                 h, min, s,
                                 HAVE_CIVIL | HAVE_TIME);
    {
        get_d1(ret);
        set_sg(dat, sg);
    }
    return ret;
}
            </pre> 
            </div><!-- now-source -->
            
          </div>

          

          
        </div><!-- now-method -->
      
        <div id="ordinal-method" class="method-detail ">
          <a name="method-c-ordinal"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">ordinal([year=-4712[, yday=1[, hour=0[, minute=0[, second=0[, offset=0[, start=Date::ITALY]]]]]]])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a date-time object denoting the given ordinal date.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">34</span>) <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">34</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">ordinal</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">-332</span>,<span class="ruby-value">-20</span>,<span class="ruby-value">-55</span>,<span class="ruby-value">-54</span>,<span class="ruby-string">'+7'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="ordinal-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_ordinal(int argc, VALUE *argv, VALUE klass)
{
    VALUE vy, vd, vh, vmin, vs, vof, vsg, y, fr, fr2, ret;
    int d, h, min, s, rof;
    double sg;

    rb_scan_args(argc, argv, &quot;07&quot;, &amp;vy, &amp;vd, &amp;vh, &amp;vmin, &amp;vs, &amp;vof, &amp;vsg);

    y = INT2FIX(-4712);
    d = 1;

    h = min = s = 0;
    fr2 = INT2FIX(0);
    rof = 0;
    sg = DEFAULT_SG;

    switch (argc) {
      case 7:
        val2sg(vsg, sg);
      case 6:
        val2off(vof, rof);
      case 5:
        num2int_with_frac(s, positive_inf);
      case 4:
        num2int_with_frac(min, 4);
      case 3:
        num2int_with_frac(h, 3);
      case 2:
        num2int_with_frac(d, 2);
      case 1:
        y = vy;
    }

    {
        VALUE nth;
        int ry, rd, rh, rmin, rs, rjd, rjd2, ns;

        if (!valid_ordinal_p(y, d, sg,
                             &amp;nth, &amp;ry,
                             &amp;rd, &amp;rjd,
                             &amp;ns))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        if (!c_valid_time_p(h, min, s, &amp;rh, &amp;rmin, &amp;rs))
            rb_raise(rb_eArgError, &quot;invalid date&quot;);
        canon24oc();

        rjd2 = jd_local_to_utc(rjd,
                               time_to_df(rh, rmin, rs),
                               rof);

        ret = d_complex_new_internal(klass,
                                     nth, rjd2,
                                     0, INT2FIX(0),
                                     rof, sg,
                                     0, 0, 0,
                                     rh, rmin, rs,
                                     HAVE_JD | HAVE_TIME);
    }
    add_frac();
    return ret;
}
            </pre> 
            </div><!-- ordinal-source -->
            
          </div>

          

          
        </div><!-- ordinal-method -->
      
        <div id="parse-method" class="method-detail ">
          <a name="method-c-parse"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">parse(string='-4712-01-01T00:00:00+00:00'[, comp=true[, start=ITALY]])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Parses the given representation of date and time, and creates a date
object.  This method does not function as a validator.</p>

<p>If the optional second argument is true and the detected year is in the
range “00” to “99”, makes it full.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'2001-02-03T04:05:06+07:00'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'20010203T040506+0700'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'3rd Feb 2001 04:05:06 PM'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T16:05:06+00:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="parse-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_parse(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, comp, sg;

    rb_scan_args(argc, argv, &quot;03&quot;, &amp;str, &amp;comp, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        comp = Qtrue;
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE argv2[2], hash;

        argv2[0] = str;
        argv2[1] = comp;
        hash = date_s__parse(2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- parse-source -->
            
          </div>

          

          
        </div><!-- parse-method -->
      
        <div id="rfc2822-method" class="method-detail ">
          <a name="method-c-rfc2822"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rfc2822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some typical RFC 2822 formats.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">rfc2822</span>(<span class="ruby-string">'Sat, 3 Feb 2001 04:05:06 +0700'</span>)
                         <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="rfc2822-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;Mon, 1 Jan -4712 00:00:00 +0000&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__rfc2822(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- rfc2822-source -->
            
          </div>

          

          
        </div><!-- rfc2822-method -->
      
        <div id="rfc3339-method" class="method-detail ">
          <a name="method-c-rfc3339"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rfc3339(string='-4712-01-01T00:00:00+00:00'[, start=ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some typical RFC 3339 formats.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">rfc3339</span>(<span class="ruby-string">'2001-02-03T04:05:06+07:00'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="rfc3339-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_rfc3339(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__rfc3339(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- rfc3339-source -->
            
          </div>

          

          
        </div><!-- rfc3339-method -->
      
        <div id="rfc822-method" class="method-detail ">
          <a name="method-c-rfc822"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rfc822(string='Mon, 1 Jan -4712 00:00:00 +0000'[, start=ITALY])   &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some typical RFC 2822 formats.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">rfc2822</span>(<span class="ruby-string">'Sat, 3 Feb 2001 04:05:06 +0700'</span>)
                         <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="rfc822-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_rfc2822(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;Mon, 1 Jan -4712 00:00:00 +0000&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__rfc2822(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- rfc822-source -->
            
          </div>

          

          
        </div><!-- rfc822-method -->
      
        <div id="strptime-method" class="method-detail ">
          <a name="method-c-strptime"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">strptime([string='-4712-01-01T00:00:00+00:00'[, format='%FT%T%z'[ ,start=ITALY]]])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Parses the given representation of date and time with the given template,
and creates a date object.  strptime does not support specification of
flags and width unlike strftime.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'2001-02-03T04:05:06+07:00'</span>, <span class="ruby-string">'%Y-%m-%dT%H:%M:%S%z'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'03-02-2001 04:05:06 PM'</span>, <span class="ruby-string">'%d-%m-%Y %I:%M:%S %p'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T16:05:06+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'2001-W05-6T04:05:06+07:00'</span>, <span class="ruby-string">'%G-W%V-%uT%H:%M:%S%z'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'2001 04 6 04 05 06 +7'</span>, <span class="ruby-string">'%Y %U %w %H %M %S %z'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'2001 05 6 04 05 06 +7'</span>, <span class="ruby-string">'%Y %W %u %H %M %S %z'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'-1'</span>, <span class="ruby-string">'%s'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 1969-12-31T23:59:59+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'-1000'</span>, <span class="ruby-string">'%Q'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 1969-12-31T23:59:59+00:00 ...&gt;</span>
<span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">strptime</span>(<span class="ruby-string">'sat3feb014pm+7'</span>, <span class="ruby-string">'%a%d%b%y%H%p%z'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T16:00:00+07:00 ...&gt;</span>
</pre>

<p>See also strptime(3) and strftime.</p>
            

            
            <div class="method-source-code" id="strptime-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_strptime(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, fmt, sg;

    rb_scan_args(argc, argv, &quot;03&quot;, &amp;str, &amp;fmt, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        fmt = rb_str_new2(&quot;%FT%T%z&quot;);
      case 2:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE argv2[2], hash;

        argv2[0] = str;
        argv2[1] = fmt;
        hash = date_s__strptime(2, argv2, klass);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- strptime-source -->
            
          </div>

          

          
        </div><!-- strptime-method -->
      
        <div id="xmlschema-method" class="method-detail ">
          <a name="method-c-xmlschema"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">xmlschema(string='-4712-01-01T00:00:00+00:00'[, start=ITALY])  &rarr;  datetime</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="Date.html">Date</a> object by parsing from a string
according to some typical XML Schema formats.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">xmlschema</span>(<span class="ruby-string">'2001-02-03T04:05:06+07:00'</span>)
                          <span class="ruby-comment">#=&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;</span>
</pre>
            

            
            <div class="method-source-code" id="xmlschema-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_s_xmlschema(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, &quot;02&quot;, &amp;str, &amp;sg);

    switch (argc) {
      case 0:
        str = rb_str_new2(&quot;-4712-01-01T00:00:00+00:00&quot;);
      case 1:
        sg = INT2FIX(DEFAULT_SG);
    }

    {
        VALUE hash = date_s__xmlschema(klass, str);
        return dt_new_by_frags(klass, hash, sg);
    }
}
            </pre> 
            </div><!-- xmlschema-source -->
            
          </div>

          

          
        </div><!-- xmlschema-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="iso8601-method" class="method-detail ">
          <a name="method-i-iso8601"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">iso8601([n=0])    &rarr;  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">xmlschema([n=0])  &rarr;  string</span>
            
          </div>
          
          
          <div>
  
            
            <p>This method is equivalent to strftime(‘%FT%T’).  The optional argument n is
length of fractional seconds.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'2001-02-03T04:05:06.123456789+07:00'</span>).<span class="ruby-identifier">iso8601</span>(<span class="ruby-value">9</span>)
                          <span class="ruby-comment">#=&gt; &quot;2001-02-03T04:05:06.123456789+07:00&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="iso8601-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
dt_lite_iso8601(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);

    if (argc &lt; 1)
        n = INT2FIX(0);

    return f_add(strftimev(&quot;%Y-%m-%d&quot;, self, set_tmx),
                 iso8601_timediv(self, n));
}
            </pre> 
            </div><!-- iso8601-source -->
            
          </div>

          

          
        </div><!-- iso8601-method -->
      
        <div id="jisx0301-method" class="method-detail ">
          <a name="method-i-jisx0301"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">jisx0301([n=0])  &rarr;  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a string in a JIS X 0301 format.  The optional argument n is length
of fractional seconds.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'2001-02-03T04:05:06.123456789+07:00'</span>).<span class="ruby-identifier">jisx0301</span>(<span class="ruby-value">9</span>)
                          <span class="ruby-comment">#=&gt; &quot;H13.02.03T04:05:06.123456789+07:00&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="jisx0301-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
dt_lite_jisx0301(int argc, VALUE *argv, VALUE self)
{
    VALUE n, s;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);

    if (argc &lt; 1)
        n = INT2FIX(0);

    {
        get_d1(self);
        s = jisx0301_date(m_real_local_jd(dat),
                          m_real_year(dat));
        return rb_str_append(strftimev(RSTRING_PTR(s), self, set_tmx),
                             iso8601_timediv(self, n));
    }
}
            </pre> 
            </div><!-- jisx0301-source -->
            
          </div>

          

          
        </div><!-- jisx0301-method -->
      
        <div id="rfc3339-method" class="method-detail ">
          <a name="method-i-rfc3339"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">rfc3339([n=0])  &rarr;  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>This method is equivalent to strftime(‘%FT%T’).  The optional argument n is
length of fractional seconds.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'2001-02-03T04:05:06.123456789+07:00'</span>).<span class="ruby-identifier">rfc3339</span>(<span class="ruby-value">9</span>)
                          <span class="ruby-comment">#=&gt; &quot;2001-02-03T04:05:06.123456789+07:00&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="rfc3339-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
dt_lite_rfc3339(int argc, VALUE *argv, VALUE self)
{
    return dt_lite_iso8601(argc, argv, self);
}
            </pre> 
            </div><!-- rfc3339-source -->
            
          </div>

          

          
        </div><!-- rfc3339-method -->
      
        <div id="strftime-method" class="method-detail ">
          <a name="method-i-strftime"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">strftime([format='%FT%T%:z'])  &rarr;  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <pre>Formats date according to the directives in the given format
string.
The directives begins with a percent (%) character.
Any text not listed as a directive will be passed through to the
output string.

The directive consists of a percent (%) character,
zero or more flags, optional minimum field width,
optional modifier and a conversion specifier
as follows.

  %&lt;flags&gt;&lt;width&gt;&lt;modifier&gt;&lt;conversion&gt;

Flags:
  -  don't pad a numerical output.
  _  use spaces for padding.
  0  use zeros for padding.
  ^  upcase the result string.
  #  change case.
  :  use colons for %z.

The minimum field width specifies the minimum width.

The modifier is &quot;E&quot; and &quot;O&quot;.
They are ignored.

Format directives:

  Date (Year, Month, Day):
    %Y - Year with century (can be negative, 4 digits at least)
            -0001, 0000, 1995, 2009, 14292, etc.
    %C - year / 100 (round down.  20 in 2009)
    %y - year % 100 (00..99)

    %m - Month of the year, zero-padded (01..12)
            %_m  blank-padded ( 1..12)
            %-m  no-padded (1..12)
    %B - The full month name (``January'')
            %^B  uppercased (``JANUARY'')
    %b - The abbreviated month name (``Jan'')
            %^b  uppercased (``JAN'')
    %h - Equivalent to %b

    %d - Day of the month, zero-padded (01..31)
            %-d  no-padded (1..31)
    %e - Day of the month, blank-padded ( 1..31)

    %j - Day of the year (001..366)

  Time (Hour, Minute, Second, Subsecond):
    %H - Hour of the day, 24-hour clock, zero-padded (00..23)
    %k - Hour of the day, 24-hour clock, blank-padded ( 0..23)
    %I - Hour of the day, 12-hour clock, zero-padded (01..12)
    %l - Hour of the day, 12-hour clock, blank-padded ( 1..12)
    %P - Meridian indicator, lowercase (``am'' or ``pm'')
    %p - Meridian indicator, uppercase (``AM'' or ``PM'')

    %M - Minute of the hour (00..59)

    %S - Second of the minute (00..59)

    %L - Millisecond of the second (000..999)
    %N - Fractional seconds digits, default is 9 digits (nanosecond)
            %3N  millisecond (3 digits)   %15N femtosecond (15 digits)
            %6N  microsecond (6 digits)   %18N attosecond  (18 digits)
            %9N  nanosecond  (9 digits)   %21N zeptosecond (21 digits)
            %12N picosecond (12 digits)   %24N yoctosecond (24 digits)

  Time zone:
    %z - Time zone as hour and minute offset from UTC (e.g. +0900)
            %:z - hour and minute offset from UTC with a colon (e.g. +09:00)
            %::z - hour, minute and second offset from UTC (e.g. +09:00:00)
            %:::z - hour, minute and second offset from UTC
                                              (e.g. +09, +09:30, +09:30:30)
    %Z - Time zone abbreviation name or something similar information.

  Weekday:
    %A - The full weekday name (``Sunday'')
            %^A  uppercased (``SUNDAY'')
    %a - The abbreviated name (``Sun'')
            %^a  uppercased (``SUN'')
    %u - Day of the week (Monday is 1, 1..7)
    %w - Day of the week (Sunday is 0, 0..6)

  ISO 8601 week-based year and week number:
  The week 1 of YYYY starts with a Monday and includes YYYY-01-04.
  The days in the year before the first week are in the last week of
  the previous year.
    %G - The week-based year
    %g - The last 2 digits of the week-based year (00..99)
    %V - Week number of the week-based year (01..53)

  Week number:
  The week 1 of YYYY starts with a Sunday or Monday (according to %U
  or %W).  The days in the year before the first week are in week 0.
    %U - Week number of the year.  The week starts with Sunday.  (00..53)
    %W - Week number of the year.  The week starts with Monday.  (00..53)

  Seconds since the Unix Epoch:
    %s - Number of seconds since 1970-01-01 00:00:00 UTC.
    %Q - Number of milliseconds since 1970-01-01 00:00:00 UTC.

  Literal string:
    %n - Newline character (\n)
    %t - Tab character (\t)
    %% - Literal ``%'' character

  Combination:
    %c - date and time (%a %b %e %T %Y)
    %D - Date (%m/%d/%y)
    %F - The ISO 8601 date format (%Y-%m-%d)
    %v - VMS date (%e-%b-%Y)
    %x - Same as %D
    %X - Same as %T
    %r - 12-hour time (%I:%M:%S %p)
    %R - 24-hour time (%H:%M)
    %T - 24-hour time (%H:%M:%S)
    %+ - date(1) (%a %b %e %H:%M:%S %Z %Y)

This method is similar to strftime() function defined in ISO C and POSIX.
Several directives (%a, %A, %b, %B, %c, %p, %r, %x, %X, %E*, %O* and %Z)
are locale dependent in the function.
However this method is locale independent.
So, the result may differ even if a same format string is used in other
systems such as C.
It is good practice to avoid %x and %X because there are corresponding
locale independent representations, %D and %T.

Examples:

  d = DateTime.new(2007,11,19,8,37,48,&quot;-06:00&quot;)
                            #=&gt; #&lt;DateTime: 2007-11-19T08:37:48-0600 ...&gt;
  d.strftime(&quot;Printed on %m/%d/%Y&quot;)   #=&gt; &quot;Printed on 11/19/2007&quot;
  d.strftime(&quot;at %I:%M%p&quot;)            #=&gt; &quot;at 08:37AM&quot;

Various ISO 8601 formats:
  %Y%m%d           =&gt; 20071119                  Calendar date (basic)
  %F               =&gt; 2007-11-19                Calendar date (extended)
  %Y-%m            =&gt; 2007-11                   Calendar date, reduced accuracy, specific month
  %Y               =&gt; 2007                      Calendar date, reduced accuracy, specific year
  %C               =&gt; 20                        Calendar date, reduced accuracy, specific century
  %Y%j             =&gt; 2007323                   Ordinal date (basic)
  %Y-%j            =&gt; 2007-323                  Ordinal date (extended)
  %GW%V%u          =&gt; 2007W471                  Week date (basic)
  %G-W%V-%u        =&gt; 2007-W47-1                Week date (extended)
  %GW%V            =&gt; 2007W47                   Week date, reduced accuracy, specific week (basic)
  %G-W%V           =&gt; 2007-W47                  Week date, reduced accuracy, specific week (extended)
  %H%M%S           =&gt; 083748                    Local time (basic)
  %T               =&gt; 08:37:48                  Local time (extended)
  %H%M             =&gt; 0837                      Local time, reduced accuracy, specific minute (basic)
  %H:%M            =&gt; 08:37                     Local time, reduced accuracy, specific minute (extended)
  %H               =&gt; 08                        Local time, reduced accuracy, specific hour
  %H%M%S,%L        =&gt; 083748,000                Local time with decimal fraction, comma as decimal sign (basic)
  %T,%L            =&gt; 08:37:48,000              Local time with decimal fraction, comma as decimal sign (extended)
  %H%M%S.%L        =&gt; 083748.000                Local time with decimal fraction, full stop as decimal sign (basic)
  %T.%L            =&gt; 08:37:48.000              Local time with decimal fraction, full stop as decimal sign (extended)
  %H%M%S%z         =&gt; 083748-0600               Local time and the difference from UTC (basic)
  %T%:z            =&gt; 08:37:48-06:00            Local time and the difference from UTC (extended)
  %Y%m%dT%H%M%S%z  =&gt; 20071119T083748-0600      Date and time of day for calendar date (basic)
  %FT%T%:z         =&gt; 2007-11-19T08:37:48-06:00 Date and time of day for calendar date (extended)
  %Y%jT%H%M%S%z    =&gt; 2007323T083748-0600       Date and time of day for ordinal date (basic)
  %Y-%jT%T%:z      =&gt; 2007-323T08:37:48-06:00   Date and time of day for ordinal date (extended)
  %GW%V%uT%H%M%S%z =&gt; 2007W471T083748-0600      Date and time of day for week date (basic)
  %G-W%V-%uT%T%:z  =&gt; 2007-W47-1T08:37:48-06:00 Date and time of day for week date (extended)
  %Y%m%dT%H%M      =&gt; 20071119T0837             Calendar date and local time (basic)
  %FT%R            =&gt; 2007-11-19T08:37          Calendar date and local time (extended)
  %Y%jT%H%MZ       =&gt; 2007323T0837Z             Ordinal date and UTC of day (basic)
  %Y-%jT%RZ        =&gt; 2007-323T08:37Z           Ordinal date and UTC of day (extended)
  %GW%V%uT%H%M%z   =&gt; 2007W471T0837-0600        Week date and local time and difference from UTC (basic)
  %G-W%V-%uT%R%:z  =&gt; 2007-W47-1T08:37-06:00    Week date and local time and difference from UTC (extended)</pre>

<p>See also strftime(3) and strptime.</p>
            

            
            <div class="method-source-code" id="strftime-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
dt_lite_strftime(int argc, VALUE *argv, VALUE self)
{
    return date_strftime_internal(argc, argv, self,
                                  &quot;%Y-%m-%dT%H:%M:%S%:z&quot;, set_tmx);
}
            </pre> 
            </div><!-- strftime-source -->
            
          </div>

          

          
        </div><!-- strftime-method -->
      
        <div id="to_date-method" class="method-detail ">
          <a name="method-i-to_date"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_date  &rarr;  date</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a <a href="Date.html">Date</a> object which denotes self.</p>
            

            
            <div class="method-source-code" id="to_date-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_to_date(VALUE self)
{
    get_d1a(self);

    if (simple_dat_p(adat)) {
        VALUE new = d_lite_s_alloc_simple(cDate);
        {
            get_d1b(new);
            bdat-&gt;s = adat-&gt;s;
            bdat-&gt;s.jd = m_local_jd(adat);
            return new;
        }
    }
    else {
        VALUE new = d_lite_s_alloc_simple(cDate);
        {
            get_d1b(new);
            copy_complex_to_simple(new, &amp;bdat-&gt;s, &amp;adat-&gt;c)
            bdat-&gt;s.jd = m_local_jd(adat);
            bdat-&gt;s.flags &amp;= ~(HAVE_DF | HAVE_TIME | COMPLEX_DAT);
            return new;
        }
    }
}
            </pre> 
            </div><!-- to_date-source -->
            
          </div>

          

          
        </div><!-- to_date-method -->
      
        <div id="to_datetime-method" class="method-detail ">
          <a name="method-i-to_datetime"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_datetime  &rarr;  self</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns self.</p>
            

            
            <div class="method-source-code" id="to_datetime-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_to_datetime(VALUE self)
{
    return self;
}
            </pre> 
            </div><!-- to_datetime-source -->
            
          </div>

          

          
        </div><!-- to_datetime-method -->
      
        <div id="to_s-method" class="method-detail ">
          <a name="method-i-to_s"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_s  &rarr;  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a string in an ISO 8601 format (This method doesn’t use the
expanded representations).</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">new</span>(<span class="ruby-value">2001</span>,<span class="ruby-value">2</span>,<span class="ruby-value">3</span>,<span class="ruby-value">4</span>,<span class="ruby-value">5</span>,<span class="ruby-value">6</span>,<span class="ruby-string">'-7'</span>).<span class="ruby-identifier">to_s</span>
                         <span class="ruby-comment">#=&gt; &quot;2001-02-03T04:05:06-07:00&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="to_s-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
dt_lite_to_s(VALUE self)
{
    return strftimev(&quot;%Y-%m-%dT%H:%M:%S%:z&quot;, self, set_tmx);
}
            </pre> 
            </div><!-- to_s-source -->
            
          </div>

          

          
        </div><!-- to_s-method -->
      
        <div id="to_time-method" class="method-detail ">
          <a name="method-i-to_time"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_time  &rarr;  time</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a <a href="Time.html">Time</a> object which denotes self.</p>
            

            
            <div class="method-source-code" id="to_time-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
datetime_to_time(VALUE self)
{
    volatile VALUE dup = dup_obj_with_new_offset(self, 0);
    {
        VALUE t;

        get_d1(dup);

        t = f_utc6(rb_cTime,
                   m_real_year(dat),
                   INT2FIX(m_mon(dat)),
                   INT2FIX(m_mday(dat)),
                   INT2FIX(m_hour(dat)),
                   INT2FIX(m_min(dat)),
                   f_add(INT2FIX(m_sec(dat)),
                         m_sf_in_sec(dat)));
        return f_getlocal(t);
    }
}
            </pre> 
            </div><!-- to_time-source -->
            
          </div>

          

          
        </div><!-- to_time-method -->
      
        <div id="xmlschema-method" class="method-detail ">
          <a name="method-i-xmlschema"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">iso8601([n=0])    &rarr;  string</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">xmlschema([n=0])  &rarr;  string</span>
            
          </div>
          
          
          <div>
  
            
            <p>This method is equivalent to strftime(‘%FT%T’).  The optional argument n is
length of fractional seconds.</p>

<pre class="ruby"><span class="ruby-constant">DateTime</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">'2001-02-03T04:05:06.123456789+07:00'</span>).<span class="ruby-identifier">iso8601</span>(<span class="ruby-value">9</span>)
                          <span class="ruby-comment">#=&gt; &quot;2001-02-03T04:05:06.123456789+07:00&quot;</span>
</pre>
            

            
            <div class="method-source-code" id="xmlschema-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
dt_lite_iso8601(int argc, VALUE *argv, VALUE self)
{
    VALUE n;

    rb_scan_args(argc, argv, &quot;01&quot;, &amp;n);

    if (argc &lt; 1)
        n = INT2FIX(0);

    return f_add(strftimev(&quot;%Y-%m-%d&quot;, self, set_tmx),
                 iso8601_timediv(self, n));
}
            </pre> 
            </div><!-- xmlschema-source -->
            
          </div>

          

          
        </div><!-- xmlschema-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_DateTime_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_DateTime_versioned").load("/associated/2_2_3/DateTime.html");</script> <div id='tx_DateTime' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_DateTime").load("/associated/DateTime.html");</script> 
      
  <!-- disqus ? -->
   <div class='info'>
  <p>Commenting is here to help enhance the documentation.  For example, code samples, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href='http://www.ruby-lang.org/en/community/mailing-lists/'>Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href='http://bugs.ruby-lang.org' >file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  <p>If you want to help improve the Ruby documentation, please visit <a href='http://documenting-ruby.org/'>Documenting-ruby.org</a>.</p> 
    </div>


  
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
        <div id="disqus_thread"></div>
  <script type="text/javascript">
     function setDisqusUrl(){
      var _loc = window.location.href;
      disqus_url = _loc.split("?")[0];
    }

     var disqus_url;
     
    
     setDisqusUrl();
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2_2_3</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>. <a href="http://neurogami.com">Hack your world.  Feed your head.  Live curious</a>.</p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.33.0</small>.</p>
  </div>
</div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-335317-2', 'auto');
  ga('send', 'pageview');

</script>


    
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
//		var img_h = $("img.carbonad-image").css('height');
		//if(img_h != undefined) { //---
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
		//} // ---
	} // end loadPlusdocs

   function loadInline(json){
    for (var lookFor in json) {
      $(lookFor).after(json[lookFor]);
     }
  } // end loadPlusdocs


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2_2_3/plus_DateTime.html', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


    $.ajax({
    dataType: "json",
     url: '/associated/2_2_3/inline_DateTime.js',
     success: function(json) {
			setTimeout(function() {
				loadInline(json);
				}, 2000);
			}
   });

		});
</script>
		
</body>
</html>



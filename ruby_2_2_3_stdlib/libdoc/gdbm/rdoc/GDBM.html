<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <!-- classpage -- >
    <!-- RD version: 0.33.0  -->
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />
  <meta name='description' content='  Class : GDBM  -   Ruby 2_2_3 ' />
  <meta content="2015-10-03 10:47:10 -0500" http-equiv="change-date" />
  <!-- rel_prefix  = ''  ENV['RDOC_FOR_WEBSITE']   = true-->
    
    
    
  <!-- rel_prefix = '.'   asset_rel_prefix = ''  --> 
  <title>Class: GDBM (Ruby 2_2_3) </title>
  <!-- link rel="stylesheet" href=".css/obf.css"  -->
  <link rel="stylesheet" href="css/inuit.css" >
  <link rel="stylesheet" href="css/grid.inuit.css" >
  <link rel="stylesheet" href="css/2011.css" type="text/css" >
  <link rel="stylesheet" href="css/rdoc.css" type="text/css" >

  <script src="/js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="/js/rubydoc.js" type="text/javascript" charset="utf-8"></script> 

 
<script src="/js/highlight.min.js"></script>
<script> 
  hljs.tabReplace = '  ';
  hljs.initHighlightingOnLoad();
  </script> 

  <style type='text/css'>

    #vulns-alert #vulns{
      background-color: #c33 ! important;
      width: 100%;
      text-align: center;
   }
   
   #vulns-alert #vulns a {
    color: #F99 ! important;
   }
 </style>

</head>

<body id="top" class="class rdocstar">
<div id='actionbar' >
<div class='wrapper'>
  <ul class='grids g0'>
	<li class='grid-2' ><a href='/' target='_top' >Home</a></li>
	<li class='grid-2' ><a href='/core' target='_top' >Core </a></li>
	<li class='grid-2' ><a href='/stdlib' target='_top' >Std-lib </a></li>

	 <!-- li class='grid-2' ><a href='/zems' target='_top' >Zems</a></li -->
   <li class='grid-2' ><a href='/downloads' target='_top' >Downloads</a></li>
	 <li class='grid-5 right' id='rd-action-search'><form id="searchbox_011815814100681837392:wnccv6st5qk" action="http://ruby-doc.com/search.html"><input type="hidden" name="cx" value="011815814100681837392:wnccv6st5qk" ><input  id='rd-search-input' name="q" type="text" size="20" >&#160;&#160;<input type="submit" name="sa" value="Search" ><input type="hidden" name="cof" value="FORID:9" ></form></li>
	</ul>
</div>
<span id='vulns-alert'></span>
<!-- VERSION HEADER for 2_2_3 NOT FOUND --></div> <!-- end action bar -->
 <div class='wrapper'>
  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="./index.html">Home</a>
          <a href="./index.html#classes">Classes</a>
          <a href="./index.html#methods">Methods</a>
          
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul id='file-metadata'>

          
          
          
          <li class='in-file'>gdbm/gdbm.c</li>      
            
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Object</p>
        
      </div>
      

      

      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-c-open">::open</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-cachesize-3D">#cachesize=</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-close">#close</a></li>
          
          <li><a href="#method-i-closed-3F">#closed?</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_if">#delete_if</a></li>
          
          <li><a href="#method-i-each">#each</a></li>
          
          <li><a href="#method-i-each_key">#each_key</a></li>
          
          <li><a href="#method-i-each_pair">#each_pair</a></li>
          
          <li><a href="#method-i-each_value">#each_value</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-fastmode-3D">#fastmode=</a></li>
          
          <li><a href="#method-i-fetch">#fetch</a></li>
          
          <li><a href="#method-i-has_key-3F">#has_key?</a></li>
          
          <li><a href="#method-i-has_value-3F">#has_value?</a></li>
          
          <li><a href="#method-i-include-3F">#include?</a></li>
          
          <li><a href="#method-i-invert">#invert</a></li>
          
          <li><a href="#method-i-key">#key</a></li>
          
          <li><a href="#method-i-key-3F">#key?</a></li>
          
          <li><a href="#method-i-keys">#keys</a></li>
          
          <li><a href="#method-i-length">#length</a></li>
          
          <li><a href="#method-i-member-3F">#member?</a></li>
          
          <li><a href="#method-i-reject">#reject</a></li>
          
          <li><a href="#method-i-reject-21">#reject!</a></li>
          
          <li><a href="#method-i-reorganize">#reorganize</a></li>
          
          <li><a href="#method-i-replace">#replace</a></li>
          
          <li><a href="#method-i-select">#select</a></li>
          
          <li><a href="#method-i-shift">#shift</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
          <li><a href="#method-i-store">#store</a></li>
          
          <li><a href="#method-i-sync">#sync</a></li>
          
          <li><a href="#method-i-syncmode-3D">#syncmode=</a></li>
          
          <li><a href="#method-i-to_a">#to_a</a></li>
          
          <li><a href="#method-i-to_hash">#to_hash</a></li>
          
          <li><a href="#method-i-update">#update</a></li>
          
          <li><a href="#method-i-value-3F">#value?</a></li>
          
          <li><a href="#method-i-values">#values</a></li>
          
          <li><a href="#method-i-values_at">#values_at</a></li>
          
        </ul>
      </div>
      

      
      <!-- Included Modules -->
      <div id="includes-section" class="section">
        <h3 class="section-header">Included Modules</h3>
        <ul class="link-list">
        
        
          <li><span class="include">Enumerable</span></li>
        
        
        </ul>
      </div>
      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="./images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
          
          
          
          <li><a href="./GDBM.html">GDBM</a></li>
        
          
          
          <li><a href="./GDBMError.html">GDBMError</a></li>
        
          
          
          <li><a href="./GDBMFatalError.html">GDBMFatalError</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div> <!-- metadata -->
  <div class='adzbox'  id="azk83167">
    
   <div id="carbonads-container"><div class="carbonad"><div id="azcarbon"></div><script type="text/javascript">var z = document.createElement("script"); z.type = "text/javascript"; z.async = true; z.src = "http://engine.carbonads.com/z/19647/azcarbon_2_1_0_VERT"; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(z, s);</script></div></div>
<script type="text/javascript">
  function checkCarbs() {
    var searchFor = ".car" + "bona" + "d-tag";
    var ctext = $(searchFor);
    if (!ctext.length ) {
     // alert("Cannot find element with class " + searchFor );
      $("#azcarbon").append("<div class='rd-ab-msg'>If you are running an ad blocker please consider white-listing ruby-doc.org. <br><br>Thank you.</div>");
    }
  }
//  window.setTimeout(checkCarbs,3000); 
</script>

   
  </div> 
  <div id="documentation">
    <h1 class="class">GDBM</h1>

    <div id="description" class="description">
      
<h2 id="class-GDBM-label-Summary">Summary<span><a href="#class-GDBM-label-Summary">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Ruby extension for GNU dbm (gdbm) -- a simple database engine for storing
key-value pairs on disk.</p>

<h2 id="class-GDBM-label-Description">Description<span><a href="#class-GDBM-label-Description">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>GNU dbm is a library for simple databases. A database is a file that stores
key-value pairs. Gdbm allows the user to store, retrieve, and delete data
by key. It furthermore allows a non-sorted traversal of all key-value
pairs. A gdbm database thus provides the same functionality as a hash. As
with objects of the Hash class, elements can be accessed with
<code>[]</code>. Furthermore, <a href="GDBM.html">GDBM</a> mixes in the
Enumerable module, thus providing convenient methods such as find, collect,
map, etc.</p>

<p>A process is allowed to open several different databases at the same time.
A process can open a database as a "reader" or a "writer". Whereas a reader
has only read-access to the database, a writer has read- and write-access.
A database can be accessed either by any number of readers or by exactly
one writer at the same time.</p>

<h2 id="class-GDBM-label-Examples">Examples<span><a href="#class-GDBM-label-Examples">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ol><li>
<p>Opening/creating a database, and filling it with some entries:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'gdbm'</span>

<span class="ruby-identifier">gdbm</span> = <span class="ruby-constant">GDBM</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;fruitstore.db&quot;</span>)
<span class="ruby-identifier">gdbm</span>[<span class="ruby-string">&quot;ananas&quot;</span>]    = <span class="ruby-string">&quot;3&quot;</span>
<span class="ruby-identifier">gdbm</span>[<span class="ruby-string">&quot;banana&quot;</span>]    = <span class="ruby-string">&quot;8&quot;</span>
<span class="ruby-identifier">gdbm</span>[<span class="ruby-string">&quot;cranberry&quot;</span>] = <span class="ruby-string">&quot;4909&quot;</span>
<span class="ruby-identifier">gdbm</span>.<span class="ruby-identifier">close</span>
</pre>
</li><li>
<p>Reading out a database:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'gdbm'</span>

<span class="ruby-identifier">gdbm</span> = <span class="ruby-constant">GDBM</span>.<span class="ruby-identifier">new</span>(<span class="ruby-string">&quot;fruitstore.db&quot;</span>)
<span class="ruby-identifier">gdbm</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;#{key}: #{value}\n&quot;</span>
<span class="ruby-keyword">end</span>
<span class="ruby-identifier">gdbm</span>.<span class="ruby-identifier">close</span>
</pre>

<p>produces</p>

<pre>banana: 8
ananas: 3
cranberry: 4909</pre>
</li></ol>

<h2 id="class-GDBM-label-Links">Links<span><a href="#class-GDBM-label-Links">&para;</a> <a href="#top">&uarr;</a></span></h2>
<ul><li>
<p><a href="http://www.gnu.org/software/gdbm">www.gnu.org/software/gdbm</a>/</p>
</li></ul>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="FAST">FAST</a></dt>
          
          <dd class="description"><p>flag for new and open. this flag is obsolete for gdbm &gt;= 1.8</p></dd>
          
        
          <dt><a name="NEWDB">NEWDB</a></dt>
          
          <dd class="description"><p>open database as a writer; overwrite any existing databases</p></dd>
          
        
          <dt><a name="NOLOCK">NOLOCK</a></dt>
          
          <dd class="description"><p>flag for new and open</p></dd>
          
        
          <dt><a name="READER">READER</a></dt>
          
          <dd class="description"><p>open database as a reader</p></dd>
          
        
          <dt><a name="SYNC">SYNC</a></dt>
          
          <dd class="description"><p>flag for new and open. only for gdbm &gt;= 1.8</p></dd>
          
        
          <dt><a name="VERSION">VERSION</a></dt>
          
          <dd class="description"><p>version of the gdbm library</p></dd>
          
        
          <dt><a name="WRCREAT">WRCREAT</a></dt>
          
          <dd class="description"><p>open database as a writer; if the database does not exist, create a new one</p></dd>
          
        
          <dt><a name="WRITER">WRITER</a></dt>
          
          <dd class="description"><p>open database as a writer</p></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">new(filename, mode = 0666, flags = nil)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Creates a new <a href="GDBM.html">GDBM</a> instance by opening a gdbm file
named <em>filename</em>. If the file does not exist, a new file with file
mode <em>mode</em> will be created. <em>flags</em> may be one of the
following:</p>
<ul><li>
<p><strong>READER</strong>  - open as a reader</p>
</li><li>
<p><strong>WRITER</strong>  - open as a writer</p>
</li><li>
<p><strong>WRCREAT</strong> - open as a writer; if the database does not
exist, create a new one</p>
</li><li>
<p><strong>NEWDB</strong>   - open as a writer; overwrite any existing
databases</p>
</li></ul>

<p>The values <strong>WRITER</strong>, <strong>WRCREAT</strong> and
<strong>NEWDB</strong> may be combined with the following values by bitwise
or:</p>
<ul><li>
<p><strong>SYNC</strong>    - cause all database operations to be synchronized
to the disk</p>
</li><li>
<p><strong>NOLOCK</strong>  - do not lock the database file</p>
</li></ul>

<p>If no <em>flags</em> are specified, the <a href="GDBM.html">GDBM</a> object
will try to open the database file as a writer and will create it if it
does not already exist (cf. flag <code>WRCREAT</code>). If this fails (for
instance, if another process has already opened the database as a reader),
it will try to open the database file as a reader (cf. flag
<code>READER</code>).</p>
            

            
            <div class="method-source-code" id="new-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_initialize(int argc, VALUE *argv, VALUE obj)
{
    VALUE file, vmode, vflags;
    GDBM_FILE dbm;
    struct dbmdata *dbmp;
    int mode, flags = 0;

    if (rb_scan_args(argc, argv, &quot;12&quot;, &amp;file, &amp;vmode, &amp;vflags) == 1) {
        mode = 0666;            /* default value */
    }
    else if (NIL_P(vmode)) {
        mode = -1;              /* return nil if DB does not exist */
    }
    else {
        mode = NUM2INT(vmode);
    }

    if (!NIL_P(vflags))
        flags = NUM2INT(vflags);

    SafeStringValue(file);

#ifdef GDBM_CLOEXEC
    /* GDBM_CLOEXEC is available since gdbm 1.10. */
    flags |= GDBM_CLOEXEC;
#endif

    if (flags &amp; RUBY_GDBM_RW_BIT) {
        flags &amp;= ~RUBY_GDBM_RW_BIT;
        dbm = gdbm_open(RSTRING_PTR(file), MY_BLOCK_SIZE,
                        flags, mode, MY_FATAL_FUNC);
    }
    else {
        dbm = 0;
        if (mode &gt;= 0)
            dbm = gdbm_open(RSTRING_PTR(file), MY_BLOCK_SIZE,
                            GDBM_WRCREAT|flags, mode, MY_FATAL_FUNC);
        if (!dbm)
            dbm = gdbm_open(RSTRING_PTR(file), MY_BLOCK_SIZE,
                            GDBM_WRITER|flags, 0, MY_FATAL_FUNC);
        if (!dbm)
            dbm = gdbm_open(RSTRING_PTR(file), MY_BLOCK_SIZE,
                            GDBM_READER|flags, 0, MY_FATAL_FUNC);
    }

    if (dbm) {
        rb_fd_fix_cloexec(gdbm_fdesc(dbm));
    }

    if (!dbm) {
        if (mode == -1) return Qnil;

        if (gdbm_errno == GDBM_FILE_OPEN_ERROR ||
            gdbm_errno == GDBM_CANT_BE_READER ||
            gdbm_errno == GDBM_CANT_BE_WRITER)
            rb_sys_fail_str(file);
        else
            rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
    }

    dbmp = ALLOC(struct dbmdata);
    free_dbm(DATA_PTR(obj));
    DATA_PTR(obj) = dbmp;
    dbmp-&gt;di_dbm = dbm;
    dbmp-&gt;di_size = -1;

    return obj;
}
            </pre> 
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->
      
        <div id="open-method" class="method-detail ">
          <a name="method-c-open"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">open(filename, mode = 0666, flags = nil)</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          <div class="method-heading">
            <span class="method-callseq">open(filename, mode = 0666, flags = nil) { |gdbm| ... }</span>
            
          </div>
          
          
          <div>
  
            
            <p>If called without a block, this is synonymous to <a
href="GDBM.html#method-c-new">::new</a>. If a block is given, the new <a
href="GDBM.html">GDBM</a> instance will be passed to the block as a
parameter, and the corresponding database file will be closed after the
execution of the block code has been finished.</p>

<p>Example for an open call with a block:</p>

<pre class="ruby"><span class="ruby-identifier">require</span> <span class="ruby-string">'gdbm'</span>
<span class="ruby-constant">GDBM</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&quot;fruitstore.db&quot;</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">gdbm</span><span class="ruby-operator">|</span>
  <span class="ruby-identifier">gdbm</span>.<span class="ruby-identifier">each_pair</span> <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">print</span> <span class="ruby-node">&quot;#{key}: #{value}\n&quot;</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>
            

            
            <div class="method-source-code" id="open-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_s_open(int argc, VALUE *argv, VALUE klass)
{
    VALUE obj = fgdbm_s_alloc(klass);

    if (NIL_P(fgdbm_initialize(argc, argv, obj))) {
        return Qnil;
    }

    if (rb_block_given_p()) {
        return rb_ensure(rb_yield, obj, fgdbm_close, obj);
    }

    return obj;
}
            </pre> 
            </div><!-- open-source -->
            
          </div>

          

          
        </div><!-- open-method -->
      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">gdbm[key] &rarr; value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Retrieves the <em>value</em> corresponding to <em>key</em>.</p>
            

            
            <div class="method-source-code" id="5B-5D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_aref(VALUE obj, VALUE keystr)
{
    return rb_gdbm_fetch3(obj, keystr);
}
            </pre> 
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->
      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">gdbm[key]= value &rarr; value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Associates the value <em>value</em> with the specified <em>key</em>.</p>
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_store(VALUE obj, VALUE keystr, VALUE valstr)
{
    datum key, val;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;

    rb_gdbm_modify(obj);
    StringValue(keystr);
    StringValue(valstr);

    key.dptr = RSTRING_PTR(keystr);
    key.dsize = RSTRING_LENINT(keystr);

    val.dptr = RSTRING_PTR(valstr);
    val.dsize = RSTRING_LENINT(valstr);

    GetDBM2(obj, dbmp, dbm);
    dbmp-&gt;di_size = -1;
    if (gdbm_store(dbm, key, val, GDBM_REPLACE)) {
        if (errno == EPERM) rb_sys_fail(0);
        rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
    }

    return valstr;
}
            </pre> 
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->
      
        <div id="cachesize-3D-method" class="method-detail ">
          <a name="method-i-cachesize-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">cachesize = size &rarr; size</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Sets the size of the internal bucket cache to <em>size</em>.</p>
            

            
            <div class="method-source-code" id="cachesize-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_set_cachesize(VALUE obj, VALUE val)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    int optval;

    GetDBM2(obj, dbmp, dbm);
    optval = FIX2INT(val);
    if (gdbm_setopt(dbm, GDBM_CACHESIZE, &amp;optval, sizeof(optval)) == -1) {
        rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
    }
    return val;
}
            </pre> 
            </div><!-- cachesize-3D-source -->
            
          </div>

          

          
        </div><!-- cachesize-3D-method -->
      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">clear &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes all the key-value pairs within <em>gdbm</em>.</p>
            

            
            <div class="method-source-code" id="clear-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_clear(VALUE obj)
{
    datum key, nextkey;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;

    rb_gdbm_modify(obj);
    GetDBM2(obj, dbmp, dbm);
    dbmp-&gt;di_size = -1;

#if 0
    while (key = gdbm_firstkey(dbm), key.dptr) {
        if (gdbm_delete(dbm, key)) {
            free(key.dptr);
            rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
        }
        free(key.dptr);
    }
#else
    while (key = gdbm_firstkey(dbm), key.dptr) {
        for (; key.dptr; key = nextkey) {
            nextkey = gdbm_nextkey(dbm, key);
            if (gdbm_delete(dbm, key)) {
                free(key.dptr);
                if (nextkey.dptr) free(nextkey.dptr);
                rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
            }
            free(key.dptr);
        }
    }
#endif
    dbmp-&gt;di_size = 0;

    return obj;
}
            </pre> 
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->
      
        <div id="close-method" class="method-detail ">
          <a name="method-i-close"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">close &rarr; nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Closes the associated database file.</p>
            

            
            <div class="method-source-code" id="close-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_close(VALUE obj)
{
    struct dbmdata *dbmp;

    GetDBM(obj, dbmp);
    gdbm_close(dbmp-&gt;di_dbm);
    dbmp-&gt;di_dbm = 0;

    return Qnil;
}
            </pre> 
            </div><!-- close-source -->
            
          </div>

          

          
        </div><!-- close-method -->
      
        <div id="closed-3F-method" class="method-detail ">
          <a name="method-i-closed-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">closed?  &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the associated database file has been closed.</p>
            

            
            <div class="method-source-code" id="closed-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_closed(VALUE obj)
{
    struct dbmdata *dbmp;

    TypedData_Get_Struct(obj, struct dbmdata, &amp;dbm_type, dbmp);
    if (dbmp == 0)
        return Qtrue;
    if (dbmp-&gt;di_dbm == 0)
        return Qtrue;

    return Qfalse;
}
            </pre> 
            </div><!-- closed-3F-source -->
            
          </div>

          

          
        </div><!-- closed-3F-method -->
      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete(key) &rarr; value or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes the key-value-pair with the specified <em>key</em> from this
database and returns the corresponding <em>value</em>. Returns nil if the
database is empty.</p>
            

            
            <div class="method-source-code" id="delete-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_delete(VALUE obj, VALUE keystr)
{
    VALUE valstr;

    valstr = fgdbm_fetch(obj, keystr, Qnil);
    rb_gdbm_delete(obj, keystr);
    return valstr;
}
            </pre> 
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->
      
        <div id="delete_if-method" class="method-detail ">
          <a name="method-i-delete_if"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">delete_if { |key, value| block } &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes every key-value pair from <em>gdbm</em> for which <em>block</em>
evaluates to true.</p>
            

            
            <div class="method-source-code" id="delete_if-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_delete_if(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr;
    VALUE ret, ary = rb_ary_tmp_new(0);
    int i, status = 0, n;

    rb_gdbm_modify(obj);
    GetDBM2(obj, dbmp, dbm);
    n = dbmp-&gt;di_size;
    dbmp-&gt;di_size = -1;

    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        OBJ_FREEZE(keystr);
        valstr = rb_gdbm_fetch2(dbm, keystr);
        ret = rb_protect(rb_yield, rb_assoc_new(rb_str_dup(keystr), valstr), &amp;status);
        if (status != 0) break;
        if (RTEST(ret)) rb_ary_push(ary, keystr);
        GetDBM2(obj, dbmp, dbm);
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++)
        rb_gdbm_delete(obj, RARRAY_PTR(ary)[i]);
    if (status) rb_jump_tag(status);
    if (n &gt; 0) dbmp-&gt;di_size = n - (int)RARRAY_LEN(ary);
    rb_ary_clear(ary);

    return obj;
}
            </pre> 
            </div><!-- delete_if-source -->
            
          </div>

          

          
        </div><!-- delete_if-method -->
      
        <div id="each-method" class="method-detail ">
          <a name="method-i-each"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_pair { |key, value| block } &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes <em>block</em> for each key in the database, passing the
<em>key</em> and the corresponding <em>value</em> as a parameter.</p>
            

            
            <div class="method-source-code" id="each-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_each_pair(VALUE obj)
{
    GDBM_FILE dbm;
    struct dbmdata *dbmp;
    VALUE keystr;

    RETURN_ENUMERATOR(obj, 0, 0);

    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_yield(rb_assoc_new(keystr, rb_gdbm_fetch2(dbm, keystr)));
        GetDBM2(obj, dbmp, dbm);
    }

    return obj;
}
            </pre> 
            </div><!-- each-source -->
            
          </div>

          

          
        </div><!-- each-method -->
      
        <div id="each_key-method" class="method-detail ">
          <a name="method-i-each_key"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_key { |key| block } &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes <em>block</em> for each key in the database, passing the
<em>key</em> as a parameter.</p>
            

            
            <div class="method-source-code" id="each_key-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_each_key(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr;

    RETURN_ENUMERATOR(obj, 0, 0);

    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_yield(keystr);
        GetDBM2(obj, dbmp, dbm);
    }
    return obj;
}
            </pre> 
            </div><!-- each_key-source -->
            
          </div>

          

          
        </div><!-- each_key-method -->
      
        <div id="each_pair-method" class="method-detail ">
          <a name="method-i-each_pair"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_pair { |key, value| block } &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes <em>block</em> for each key in the database, passing the
<em>key</em> and the corresponding <em>value</em> as a parameter.</p>
            

            
            <div class="method-source-code" id="each_pair-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_each_pair(VALUE obj)
{
    GDBM_FILE dbm;
    struct dbmdata *dbmp;
    VALUE keystr;

    RETURN_ENUMERATOR(obj, 0, 0);

    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_yield(rb_assoc_new(keystr, rb_gdbm_fetch2(dbm, keystr)));
        GetDBM2(obj, dbmp, dbm);
    }

    return obj;
}
            </pre> 
            </div><!-- each_pair-source -->
            
          </div>

          

          
        </div><!-- each_pair-method -->
      
        <div id="each_value-method" class="method-detail ">
          <a name="method-i-each_value"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">each_value { |value| block } &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Executes <em>block</em> for each key in the database, passing the
corresponding <em>value</em> as a parameter.</p>
            

            
            <div class="method-source-code" id="each_value-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_each_value(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr;

    RETURN_ENUMERATOR(obj, 0, 0);

    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_yield(rb_gdbm_fetch2(dbm, keystr));
        GetDBM2(obj, dbmp, dbm);
    }
    return obj;
}
            </pre> 
            </div><!-- each_value-source -->
            
          </div>

          

          
        </div><!-- each_value-method -->
      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">empty? &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the database is empty.</p>
            

            
            <div class="method-source-code" id="empty-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_empty_p(VALUE obj)
{
    datum key;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;

    GetDBM(obj, dbmp);
    if (dbmp-&gt;di_size &lt; 0) {
        dbm = dbmp-&gt;di_dbm;

        key = gdbm_firstkey(dbm);
        if (key.dptr) {
            free(key.dptr);
            return Qfalse;
        }
        return Qtrue;
    }

    if (dbmp-&gt;di_size == 0) return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->
      
        <div id="fastmode-3D-method" class="method-detail ">
          <a name="method-i-fastmode-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fastmode = boolean &rarr; boolean</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Turns the database’s fast mode on or off. If fast mode is turned on, gdbm
does not wait for writes to be flushed to the disk before continuing.</p>

<p>This option is obsolete for gdbm &gt;= 1.8 since fast mode is turned on by
default. See also: <a href="GDBM.html#method-i-syncmode-3D">syncmode=</a></p>
            

            
            <div class="method-source-code" id="fastmode-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_set_fastmode(VALUE obj, VALUE val)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    int optval;

    GetDBM2(obj, dbmp, dbm);
    optval = 0;
    if (RTEST(val))
        optval = 1;

    if (gdbm_setopt(dbm, GDBM_FASTMODE, &amp;optval, sizeof(optval)) == -1) {
        rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
    }
    return val;
}
            </pre> 
            </div><!-- fastmode-3D-source -->
            
          </div>

          

          
        </div><!-- fastmode-3D-method -->
      
        <div id="fetch-method" class="method-detail ">
          <a name="method-i-fetch"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">fetch(key [, default]) &rarr; value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Retrieves the <em>value</em> corresponding to <em>key</em>. If there is no
value associated with <em>key</em>, <em>default</em> will be returned
instead.</p>
            

            
            <div class="method-source-code" id="fetch-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_fetch_m(int argc, VALUE *argv, VALUE obj)
{
    VALUE keystr, valstr, ifnone;

    rb_scan_args(argc, argv, &quot;11&quot;, &amp;keystr, &amp;ifnone);
    valstr = fgdbm_fetch(obj, keystr, ifnone);
    if (argc == 1 &amp;&amp; !rb_block_given_p() &amp;&amp; NIL_P(valstr))
        rb_raise(rb_eIndexError, &quot;key not found&quot;);

    return valstr;
}
            </pre> 
            </div><!-- fetch-source -->
            
          </div>

          

          
        </div><!-- fetch-method -->
      
        <div id="has_key-3F-method" class="method-detail ">
          <a name="method-i-has_key-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">has_key?(k) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the given key <em>k</em> exists within the database.
Returns false otherwise.</p>
            

            
            <div class="method-source-code" id="has_key-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_has_key(VALUE obj, VALUE keystr)
{
    datum key;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    long len;

    StringValue(keystr);
    len = RSTRING_LENINT(keystr);
    if (TOO_LONG(len)) return Qfalse;
    key.dptr = RSTRING_PTR(keystr);
    key.dsize = (int)len;

    GetDBM2(obj, dbmp, dbm);
    if (gdbm_exists(dbm, key))
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- has_key-3F-source -->
            
          </div>

          

          
        </div><!-- has_key-3F-method -->
      
        <div id="has_value-3F-method" class="method-detail ">
          <a name="method-i-has_value-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">has_value?(v) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the given value <em>v</em> exists within the database.
Returns false otherwise.</p>
            

            
            <div class="method-source-code" id="has_value-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_has_value(VALUE obj, VALUE valstr)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr2;

    StringValue(valstr);
    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        valstr2 = rb_gdbm_fetch2(dbm, keystr);

        if (!NIL_P(valstr2) &amp;&amp;
            (int)RSTRING_LEN(valstr) == (int)RSTRING_LEN(valstr2) &amp;&amp;
            memcmp(RSTRING_PTR(valstr), RSTRING_PTR(valstr2),
                   (int)RSTRING_LEN(valstr)) == 0) {
            return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- has_value-3F-source -->
            
          </div>

          

          
        </div><!-- has_value-3F-method -->
      
        <div id="include-3F-method" class="method-detail ">
          <a name="method-i-include-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">include?(k) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the given key <em>k</em> exists within the database.
Returns false otherwise.</p>
            

            
            <div class="method-source-code" id="include-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_has_key(VALUE obj, VALUE keystr)
{
    datum key;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    long len;

    StringValue(keystr);
    len = RSTRING_LENINT(keystr);
    if (TOO_LONG(len)) return Qfalse;
    key.dptr = RSTRING_PTR(keystr);
    key.dsize = (int)len;

    GetDBM2(obj, dbmp, dbm);
    if (gdbm_exists(dbm, key))
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- include-3F-source -->
            
          </div>

          

          
        </div><!-- include-3F-method -->
      
        <div id="invert-method" class="method-detail ">
          <a name="method-i-invert"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">invert  &rarr; hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a hash created by using <em>gdbm</em>’s values as keys, and the
keys as values.</p>
            

            
            <div class="method-source-code" id="invert-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_invert(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr;
    VALUE hash = rb_hash_new();

    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {
        valstr = rb_gdbm_fetch2(dbm, keystr);

        rb_hash_aset(hash, valstr, keystr);
    }
    return hash;
}
            </pre> 
            </div><!-- invert-source -->
            
          </div>

          

          
        </div><!-- invert-method -->
      
        <div id="key-method" class="method-detail ">
          <a name="method-i-key"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key(value) &rarr; key</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the <em>key</em> for a given <em>value</em>. If several keys may
map to the same value, the key that is found first will be returned.</p>
            

            
            <div class="method-source-code" id="key-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_key(VALUE obj, VALUE valstr)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr2;

    StringValue(valstr);
    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        valstr2 = rb_gdbm_fetch2(dbm, keystr);
        if (!NIL_P(valstr2) &amp;&amp;
            (int)RSTRING_LEN(valstr) == (int)RSTRING_LEN(valstr2) &amp;&amp;
            memcmp(RSTRING_PTR(valstr), RSTRING_PTR(valstr2),
                   (int)RSTRING_LEN(valstr)) == 0) {
            return keystr;
        }
    }
    return Qnil;
}
            </pre> 
            </div><!-- key-source -->
            
          </div>

          

          
        </div><!-- key-method -->
      
        <div id="key-3F-method" class="method-detail ">
          <a name="method-i-key-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">key?(k) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the given key <em>k</em> exists within the database.
Returns false otherwise.</p>
            

            
            <div class="method-source-code" id="key-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_has_key(VALUE obj, VALUE keystr)
{
    datum key;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    long len;

    StringValue(keystr);
    len = RSTRING_LENINT(keystr);
    if (TOO_LONG(len)) return Qfalse;
    key.dptr = RSTRING_PTR(keystr);
    key.dsize = (int)len;

    GetDBM2(obj, dbmp, dbm);
    if (gdbm_exists(dbm, key))
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- key-3F-source -->
            
          </div>

          

          
        </div><!-- key-3F-method -->
      
        <div id="keys-method" class="method-detail ">
          <a name="method-i-keys"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">keys &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of all keys of this database.</p>
            

            
            <div class="method-source-code" id="keys-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_keys(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, ary;

    GetDBM2(obj, dbmp, dbm);
    ary = rb_ary_new();
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_ary_push(ary, keystr);
    }

    return ary;
}
            </pre> 
            </div><!-- keys-source -->
            
          </div>

          

          
        </div><!-- keys-method -->
      
        <div id="length-method" class="method-detail ">
          <a name="method-i-length"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">length &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of key-value pairs in this database.</p>
            

            
            <div class="method-source-code" id="length-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_length(VALUE obj)
{
    datum key, nextkey;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    int i = 0;

    GetDBM2(obj, dbmp, dbm);
    if (dbmp-&gt;di_size &gt; 0) return INT2FIX(dbmp-&gt;di_size);

    for (key = gdbm_firstkey(dbm); key.dptr; key = nextkey) {
        nextkey = gdbm_nextkey(dbm, key);
        free(key.dptr);
        i++;
    }
    dbmp-&gt;di_size = i;

    return INT2FIX(i);
}
            </pre> 
            </div><!-- length-source -->
            
          </div>

          

          
        </div><!-- length-method -->
      
        <div id="member-3F-method" class="method-detail ">
          <a name="method-i-member-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">member?(k) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the given key <em>k</em> exists within the database.
Returns false otherwise.</p>
            

            
            <div class="method-source-code" id="member-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_has_key(VALUE obj, VALUE keystr)
{
    datum key;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    long len;

    StringValue(keystr);
    len = RSTRING_LENINT(keystr);
    if (TOO_LONG(len)) return Qfalse;
    key.dptr = RSTRING_PTR(keystr);
    key.dsize = (int)len;

    GetDBM2(obj, dbmp, dbm);
    if (gdbm_exists(dbm, key))
        return Qtrue;
    return Qfalse;
}
            </pre> 
            </div><!-- member-3F-source -->
            
          </div>

          

          
        </div><!-- member-3F-method -->
      
        <div id="reject-method" class="method-detail ">
          <a name="method-i-reject"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject { |key, value| block } &rarr; hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a hash copy of <em>gdbm</em> where all key-value pairs from
<em>gdbm</em> for which <em>block</em> evaluates to true are removed. See
also: <a href="GDBM.html#method-i-delete_if">delete_if</a></p>
            

            
            <div class="method-source-code" id="reject-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_reject(VALUE obj)
{
    return rb_hash_delete_if(fgdbm_to_hash(obj));
}
            </pre> 
            </div><!-- reject-source -->
            
          </div>

          

          
        </div><!-- reject-method -->
      
        <div id="reject-21-method" class="method-detail ">
          <a name="method-i-reject-21"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reject! { |key, value| block } &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Deletes every key-value pair from <em>gdbm</em> for which <em>block</em>
evaluates to true.</p>
            

            
            <div class="method-source-code" id="reject-21-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_delete_if(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr;
    VALUE ret, ary = rb_ary_tmp_new(0);
    int i, status = 0, n;

    rb_gdbm_modify(obj);
    GetDBM2(obj, dbmp, dbm);
    n = dbmp-&gt;di_size;
    dbmp-&gt;di_size = -1;

    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        OBJ_FREEZE(keystr);
        valstr = rb_gdbm_fetch2(dbm, keystr);
        ret = rb_protect(rb_yield, rb_assoc_new(rb_str_dup(keystr), valstr), &amp;status);
        if (status != 0) break;
        if (RTEST(ret)) rb_ary_push(ary, keystr);
        GetDBM2(obj, dbmp, dbm);
    }

    for (i = 0; i &lt; RARRAY_LEN(ary); i++)
        rb_gdbm_delete(obj, RARRAY_PTR(ary)[i]);
    if (status) rb_jump_tag(status);
    if (n &gt; 0) dbmp-&gt;di_size = n - (int)RARRAY_LEN(ary);
    rb_ary_clear(ary);

    return obj;
}
            </pre> 
            </div><!-- reject-21-source -->
            
          </div>

          

          
        </div><!-- reject-21-method -->
      
        <div id="reorganize-method" class="method-detail ">
          <a name="method-i-reorganize"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">reorganize &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Reorganizes the database file. This operation removes reserved space of
elements that have already been deleted. It is only useful after a lot of
deletions in the database.</p>
            

            
            <div class="method-source-code" id="reorganize-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_reorganize(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;

    rb_gdbm_modify(obj);
    GetDBM2(obj, dbmp, dbm);
    gdbm_reorganize(dbm);
    rb_fd_fix_cloexec(gdbm_fdesc(dbm));
    return obj;
}
            </pre> 
            </div><!-- reorganize-source -->
            
          </div>

          

          
        </div><!-- reorganize-method -->
      
        <div id="replace-method" class="method-detail ">
          <a name="method-i-replace"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">replace(other) &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Replaces the content of <em>gdbm</em> with the key-value pairs of
<em>other</em>. <em>other</em> must have an <a
href="GDBM.html#method-i-each_pair">#each_pair</a> method.</p>
            

            
            <div class="method-source-code" id="replace-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_replace(VALUE obj, VALUE other)
{
    fgdbm_clear(obj);
    rb_block_call(other, rb_intern(&quot;each_pair&quot;), 0, 0, update_i, obj);
    return obj;
}
            </pre> 
            </div><!-- replace-source -->
            
          </div>

          

          
        </div><!-- replace-method -->
      
        <div id="select-method" class="method-detail ">
          <a name="method-i-select"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">select { |key, value| block } &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a new array of all key-value pairs of the database for which
<em>block</em> evaluates to true.</p>
            

            
            <div class="method-source-code" id="select-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_select(VALUE obj)
{
    VALUE new = rb_ary_new();
    GDBM_FILE dbm;
    struct dbmdata *dbmp;
    VALUE keystr;

    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {
        VALUE assoc = rb_assoc_new(keystr, rb_gdbm_fetch2(dbm, keystr));
        VALUE v = rb_yield(assoc);

        if (RTEST(v)) {
            rb_ary_push(new, assoc);
        }
        GetDBM2(obj, dbmp, dbm);
    }

    return new;
}
            </pre> 
            </div><!-- select-source -->
            
          </div>

          

          
        </div><!-- select-method -->
      
        <div id="shift-method" class="method-detail ">
          <a name="method-i-shift"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">shift &rarr; (key, value) or nil</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Removes a key-value-pair from this database and returns it as a two-item
array [ <em>key</em>, <em>value</em> ]. Returns nil if the database is
empty.</p>
            

            
            <div class="method-source-code" id="shift-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_shift(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr;

    rb_gdbm_modify(obj);
    GetDBM2(obj, dbmp, dbm);
    keystr = rb_gdbm_firstkey(dbm);
    if (NIL_P(keystr)) return Qnil;
    valstr = rb_gdbm_fetch2(dbm, keystr);
    rb_gdbm_delete(obj, keystr);

    return rb_assoc_new(keystr, valstr);
}
            </pre> 
            </div><!-- shift-source -->
            
          </div>

          

          
        </div><!-- shift-method -->
      
        <div id="size-method" class="method-detail ">
          <a name="method-i-size"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">size &rarr; fixnum</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns the number of key-value pairs in this database.</p>
            

            
            <div class="method-source-code" id="size-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_length(VALUE obj)
{
    datum key, nextkey;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    int i = 0;

    GetDBM2(obj, dbmp, dbm);
    if (dbmp-&gt;di_size &gt; 0) return INT2FIX(dbmp-&gt;di_size);

    for (key = gdbm_firstkey(dbm); key.dptr; key = nextkey) {
        nextkey = gdbm_nextkey(dbm, key);
        free(key.dptr);
        i++;
    }
    dbmp-&gt;di_size = i;

    return INT2FIX(i);
}
            </pre> 
            </div><!-- size-source -->
            
          </div>

          

          
        </div><!-- size-method -->
      
        <div id="store-method" class="method-detail ">
          <a name="method-i-store"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">store(key, value) &rarr; value</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Associates the value <em>value</em> with the specified <em>key</em>.</p>
            

            
            <div class="method-source-code" id="store-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_store(VALUE obj, VALUE keystr, VALUE valstr)
{
    datum key, val;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;

    rb_gdbm_modify(obj);
    StringValue(keystr);
    StringValue(valstr);

    key.dptr = RSTRING_PTR(keystr);
    key.dsize = RSTRING_LENINT(keystr);

    val.dptr = RSTRING_PTR(valstr);
    val.dsize = RSTRING_LENINT(valstr);

    GetDBM2(obj, dbmp, dbm);
    dbmp-&gt;di_size = -1;
    if (gdbm_store(dbm, key, val, GDBM_REPLACE)) {
        if (errno == EPERM) rb_sys_fail(0);
        rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
    }

    return valstr;
}
            </pre> 
            </div><!-- store-source -->
            
          </div>

          

          
        </div><!-- store-method -->
      
        <div id="sync-method" class="method-detail ">
          <a name="method-i-sync"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">sync &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Unless the <em>gdbm</em> object has been opened with the
<strong>SYNC</strong> flag, it is not guaranteed that database modification
operations are immediately applied to the database file. This method
ensures that all recent modifications to the database are written to the
file. Blocks until all writing operations to the disk have been finished.</p>
            

            
            <div class="method-source-code" id="sync-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_sync(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;

    rb_gdbm_modify(obj);
    GetDBM2(obj, dbmp, dbm);
    gdbm_sync(dbm);
    return obj;
}
            </pre> 
            </div><!-- sync-source -->
            
          </div>

          

          
        </div><!-- sync-method -->
      
        <div id="syncmode-3D-method" class="method-detail ">
          <a name="method-i-syncmode-3D"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">syncmode = boolean &rarr; boolean</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Turns the database’s synchronization mode on or off. If the synchronization
mode is turned on, the database’s in-memory state will be synchronized to
disk after every database modification operation. If the synchronization
mode is turned off, <a href="GDBM.html">GDBM</a> does not wait for writes
to be flushed to the disk before continuing.</p>

<p>This option is only available for gdbm &gt;= 1.8 where syncmode is turned
off by default. See also: <a
href="GDBM.html#method-i-fastmode-3D">fastmode=</a></p>
            

            
            <div class="method-source-code" id="syncmode-3D-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_set_syncmode(VALUE obj, VALUE val)
{
#if !defined(GDBM_SYNCMODE)
    fgdbm_set_fastmode(obj, RTEST(val) ? Qfalse : Qtrue);
    return val;
#else
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    int optval;

    GetDBM2(obj, dbmp, dbm);
    optval = 0;
    if (RTEST(val))
        optval = 1;

    if (gdbm_setopt(dbm, GDBM_FASTMODE, &amp;optval, sizeof(optval)) == -1) {
        rb_raise(rb_eGDBMError, &quot;%s&quot;, gdbm_strerror(gdbm_errno));
    }
    return val;
#endif
}
            </pre> 
            </div><!-- syncmode-3D-source -->
            
          </div>

          

          
        </div><!-- syncmode-3D-method -->
      
        <div id="to_a-method" class="method-detail ">
          <a name="method-i-to_a"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_a &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of all key-value pairs contained in the database.</p>
            

            
            <div class="method-source-code" id="to_a-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_to_a(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, ary;

    GetDBM2(obj, dbmp, dbm);
    ary = rb_ary_new();
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_ary_push(ary, rb_assoc_new(keystr, rb_gdbm_fetch2(dbm, keystr)));
    }

    return ary;
}
            </pre> 
            </div><!-- to_a-source -->
            
          </div>

          

          
        </div><!-- to_a-method -->
      
        <div id="to_hash-method" class="method-detail ">
          <a name="method-i-to_hash"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">to_hash &rarr; hash</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns a hash of all key-value pairs contained in the database.</p>
            

            
            <div class="method-source-code" id="to_hash-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_to_hash(VALUE obj)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, hash;

    GetDBM2(obj, dbmp, dbm);
    hash = rb_hash_new();
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        rb_hash_aset(hash, keystr, rb_gdbm_fetch2(dbm, keystr));
    }

    return hash;
}
            </pre> 
            </div><!-- to_hash-source -->
            
          </div>

          

          
        </div><!-- to_hash-method -->
      
        <div id="update-method" class="method-detail ">
          <a name="method-i-update"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">update(other) &rarr; gdbm</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Adds the key-value pairs of <em>other</em> to <em>gdbm</em>, overwriting
entries with duplicate keys with those from <em>other</em>. <em>other</em>
must have an <a href="GDBM.html#method-i-each_pair">#each_pair</a> method.</p>
            

            
            <div class="method-source-code" id="update-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_update(VALUE obj, VALUE other)
{
    rb_block_call(other, rb_intern(&quot;each_pair&quot;), 0, 0, update_i, obj);
    return obj;
}
            </pre> 
            </div><!-- update-source -->
            
          </div>

          

          
        </div><!-- update-method -->
      
        <div id="value-3F-method" class="method-detail ">
          <a name="method-i-value-3F"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">value?(v) &rarr; true or false</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns true if the given value <em>v</em> exists within the database.
Returns false otherwise.</p>
            

            
            <div class="method-source-code" id="value-3F-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_has_value(VALUE obj, VALUE valstr)
{
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE keystr, valstr2;

    StringValue(valstr);
    GetDBM2(obj, dbmp, dbm);
    for (keystr = rb_gdbm_firstkey(dbm); RTEST(keystr);
         keystr = rb_gdbm_nextkey(dbm, keystr)) {

        valstr2 = rb_gdbm_fetch2(dbm, keystr);

        if (!NIL_P(valstr2) &amp;&amp;
            (int)RSTRING_LEN(valstr) == (int)RSTRING_LEN(valstr2) &amp;&amp;
            memcmp(RSTRING_PTR(valstr), RSTRING_PTR(valstr2),
                   (int)RSTRING_LEN(valstr)) == 0) {
            return Qtrue;
        }
    }
    return Qfalse;
}
            </pre> 
            </div><!-- value-3F-source -->
            
          </div>

          

          
        </div><!-- value-3F-method -->
      
        <div id="values-method" class="method-detail ">
          <a name="method-i-values"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of all values of this database.</p>
            

            
            <div class="method-source-code" id="values-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_values(VALUE obj)
{
    datum key, nextkey;
    struct dbmdata *dbmp;
    GDBM_FILE dbm;
    VALUE valstr, ary;

    GetDBM2(obj, dbmp, dbm);
    ary = rb_ary_new();
    for (key = gdbm_firstkey(dbm); key.dptr; key = nextkey) {
        nextkey = gdbm_nextkey(dbm, key);
        valstr = rb_gdbm_fetch(dbm, key);
        free(key.dptr);
        rb_ary_push(ary, valstr);
    }

    return ary;
}
            </pre> 
            </div><!-- values-source -->
            
          </div>

          

          
        </div><!-- values-method -->
      
        <div id="values_at-method" class="method-detail ">
          <a name="method-i-values_at"></a>

          
          
          <div class="method-heading">
            <span class="method-callseq">values_at(key, ...) &rarr; array</span>
            
            <span class="method-click-advice">click to toggle source</span>
            
          </div>
          
          
          <div>
  
            
            <p>Returns an array of the values associated with each specified <em>key</em>.</p>
            

            
            <div class="method-source-code" id="values_at-source">
              <pre> <!-- method.markup_code 290 -->
               static VALUE
fgdbm_values_at(int argc, VALUE *argv, VALUE obj)
{
    VALUE new = rb_ary_new2(argc);
    int i;

    for (i=0; i&lt;argc; i++) {
        rb_ary_push(new, rb_gdbm_fetch3(obj, argv[i]));
    }

    return new;
}
            </pre> 
            </div><!-- values_at-source -->
            
          </div>

          

          
        </div><!-- values_at-method -->
      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  
  <div id='tx_GDBM_versioned' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_GDBM_versioned").load("/associated/2_2_3/GDBM.html");</script> <div id='tx_GDBM' class='associated_wrapper'></div><script type='text/javascript'>$("#tx_GDBM").load("/associated/GDBM.html");</script> 
      
  <!-- disqus ? -->
   <div class='info'>
  <p>Commenting is here to help enhance the documentation.  For example, code samples, or clarification of the documentation.</p>
  <p>If you have questions about Ruby or the documentation, please post to one of the <a href='http://www.ruby-lang.org/en/community/mailing-lists/'>Ruby mailing lists</a>.  You will get better, faster, help that way.</p>
  <p>If you wish to post a correction of the docs, please do so, but also <a href='http://bugs.ruby-lang.org' >file bug report</a> so that it can be corrected for the next release. Thank you.</p>
  <p>If you want to help improve the Ruby documentation, please visit <a href='http://documenting-ruby.org/'>Documenting-ruby.org</a>.</p> 
    </div>


  
  </div><!-- documentation -->
  <div id='dynamic'>
  </div>
      
        <div id="disqus_thread"></div>
  <script type="text/javascript">
     function setDisqusUrl(){
      var _loc = window.location.href;
      disqus_url = _loc.split("?")[0];
    }

     var disqus_url;
     
    
     setDisqusUrl();
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    // var disqus_shortname = 'rubydocbeta'; // required 
    var disqus_shortname = 'ruby-doc'; // required 


    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

      
<div class='grids wrapper' id="footer">
  <p><small>This page was generated for Ruby 2_2_3</small></p> 
  
   <p><a href="http://ruby-doc.org">Ruby-doc.org</a> is provided by <a href="http://jamesbritt.com">James Britt</a> and <a href="http://neurogami.com">Neurogami</a>. <a href="http://neurogami.com">Hack your world.  Feed your head.  Live curious</a>.</p>
 
    <p><small>Generated with Ruby-doc Rdoc Generator 0.33.0</small>.</p>
  </div>
</div>
  
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-335317-2', 'auto');
  ga('send', 'pageview');

</script>


    
 <script type='text/javascript'>
$(document).ready(function() {
      $.ajaxSetup({ cache: false });
      $("#vulns-alert").load("/associated/vulns.html");
    });

    </script>


 
		<script type='text/javascript'>

	function loadPlus(plusdocs){
//		var img_h = $("img.carbonad-image").css('height');
		//if(img_h != undefined) { //---
			$(plusdocs).find("div[class='associated_wrapper']").each (function() {
					$("#" + this.id).append($(plusdocs).find("#" + this.id ));
					});
		//} // ---
	} // end loadPlusdocs

   function loadInline(json){
    for (var lookFor in json) {
      $(lookFor).after(json[lookFor]);
     }
  } // end loadPlusdocs


$(document).ready(function() {
		$.ajaxSetup({ cache: false });
			$.get('/associated/2_2_3/plus_GDBM.html', 
			function(plusdocs) {
			setTimeout(function() {
				loadPlus(plusdocs);
				}, 2000);
			}
			);


    $.ajax({
    dataType: "json",
     url: '/associated/2_2_3/inline_GDBM.js',
     success: function(json) {
			setTimeout(function() {
				loadInline(json);
				}, 2000);
			}
   });

		});
</script>
		
</body>
</html>



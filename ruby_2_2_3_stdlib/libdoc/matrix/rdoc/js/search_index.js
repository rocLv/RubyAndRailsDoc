var search_data = {"index":{"searchIndex":["matrix","eigenvaluedecomposition","lupdecomposition","vector","zerovectorerror","*()","*()","**()","+()","+()","+@()","+@()","-()","-()","-@()","-@()","/()","/()","==()","==()","i()","[]()","[]()","[]()","[]()","adjugate()","angle_with()","basis()","build()","clone()","clone()","coerce()","coerce()","cofactor()","cofactor_expansion()","collect()","collect()","collect2()","column()","column_vector()","column_vectors()","columns()","component()","component()","conj()","conjugate()","covector()","cross()","cross_product()","d()","det()","det()","det_e()","determinant()","determinant()","determinant_e()","diagonal()","diagonal?()","dot()","each()","each()","each2()","each_with_index()","eigen()","eigensystem()","eigenvalue_matrix()","eigenvalues()","eigenvector_matrix()","eigenvector_matrix_inv()","eigenvectors()","element()","element()","elements()","elements_to_f()","elements_to_f()","elements_to_i()","elements_to_i()","elements_to_r()","elements_to_r()","empty()","empty?()","eql?()","eql?()","find_index()","first_minor()","hash()","hash()","hermitian?()","hstack()","hstack()","identity()","imag()","imaginary()","independent?()","independent?()","index()","inner_product()","inspect()","inspect()","inv()","inverse()","l()","laplace_expansion()","lower_triangular?()","lup()","lup_decomposition()","magnitude()","map()","map()","map2()","minor()","new()","new()","new()","new()","norm()","normal?()","normalize()","orthogonal?()","p()","permutation?()","r()","rank()","rank_e()","real()","real?()","rect()","rectangular()","regular?()","round()","row()","row_count()","row_size()","row_vector()","row_vectors()","rows()","scalar()","singular?()","singular?()","size()","solve()","square?()","symmetric?()","t()","to_a()","to_a()","to_a()","to_a()","to_ary()","to_ary()","to_s()","to_s()","tr()","trace()","transpose()","u()","unit()","unitary?()","upper_triangular?()","v()","v_inv()","vstack()","vstack()","zero()","zero?()"],"longSearchIndex":["matrix","matrix::eigenvaluedecomposition","matrix::lupdecomposition","vector","vector::zerovectorerror","matrix#*()","vector#*()","matrix#**()","matrix#+()","vector#+()","matrix#+@()","vector#+@()","matrix#-()","vector#-()","matrix#-@()","vector#-@()","matrix#/()","vector#/()","matrix#==()","vector#==()","matrix::i()","matrix#[]()","matrix::[]()","vector::[]()","vector#[]()","matrix#adjugate()","vector#angle_with()","vector::basis()","matrix::build()","matrix#clone()","vector#clone()","matrix#coerce()","vector#coerce()","matrix#cofactor()","matrix#cofactor_expansion()","matrix#collect()","vector#collect()","vector#collect2()","matrix#column()","matrix::column_vector()","matrix#column_vectors()","matrix::columns()","matrix#component()","vector#component()","matrix#conj()","matrix#conjugate()","vector#covector()","vector#cross()","vector#cross_product()","matrix::eigenvaluedecomposition#d()","matrix#det()","matrix::lupdecomposition#det()","matrix#det_e()","matrix#determinant()","matrix::lupdecomposition#determinant()","matrix#determinant_e()","matrix::diagonal()","matrix#diagonal?()","vector#dot()","matrix#each()","vector#each()","vector#each2()","matrix#each_with_index()","matrix#eigen()","matrix#eigensystem()","matrix::eigenvaluedecomposition#eigenvalue_matrix()","matrix::eigenvaluedecomposition#eigenvalues()","matrix::eigenvaluedecomposition#eigenvector_matrix()","matrix::eigenvaluedecomposition#eigenvector_matrix_inv()","matrix::eigenvaluedecomposition#eigenvectors()","matrix#element()","vector#element()","vector::elements()","matrix#elements_to_f()","vector#elements_to_f()","matrix#elements_to_i()","vector#elements_to_i()","matrix#elements_to_r()","vector#elements_to_r()","matrix::empty()","matrix#empty?()","matrix#eql?()","vector#eql?()","matrix#find_index()","matrix#first_minor()","matrix#hash()","vector#hash()","matrix#hermitian?()","matrix#hstack()","matrix::hstack()","matrix::identity()","matrix#imag()","matrix#imaginary()","vector#independent?()","vector::independent?()","matrix#index()","vector#inner_product()","matrix#inspect()","vector#inspect()","matrix#inv()","matrix#inverse()","matrix::lupdecomposition#l()","matrix#laplace_expansion()","matrix#lower_triangular?()","matrix#lup()","matrix#lup_decomposition()","vector#magnitude()","matrix#map()","vector#map()","vector#map2()","matrix#minor()","matrix::new()","matrix::eigenvaluedecomposition::new()","matrix::lupdecomposition::new()","vector::new()","vector#norm()","matrix#normal?()","vector#normalize()","matrix#orthogonal?()","matrix::lupdecomposition#p()","matrix#permutation?()","vector#r()","matrix#rank()","matrix#rank_e()","matrix#real()","matrix#real?()","matrix#rect()","matrix#rectangular()","matrix#regular?()","matrix#round()","matrix#row()","matrix#row_count()","matrix#row_size()","matrix::row_vector()","matrix#row_vectors()","matrix::rows()","matrix::scalar()","matrix#singular?()","matrix::lupdecomposition#singular?()","vector#size()","matrix::lupdecomposition#solve()","matrix#square?()","matrix#symmetric?()","matrix#t()","matrix#to_a()","matrix::eigenvaluedecomposition#to_a()","matrix::lupdecomposition#to_a()","vector#to_a()","matrix::eigenvaluedecomposition#to_ary()","matrix::lupdecomposition#to_ary()","matrix#to_s()","vector#to_s()","matrix#tr()","matrix#trace()","matrix#transpose()","matrix::lupdecomposition#u()","matrix::unit()","matrix#unitary?()","matrix#upper_triangular?()","matrix::eigenvaluedecomposition#v()","matrix::eigenvaluedecomposition#v_inv()","matrix::vstack()","matrix#vstack()","matrix::zero()","matrix#zero?()"],"info":[["Matrix","","Matrix.html","","<p>The <code>Matrix</code> class represents a mathematical matrix. It provides\nmethods for creating matrices, operating …\n"],["Matrix::EigenvalueDecomposition","","Matrix/EigenvalueDecomposition.html","","<p>Eigenvalues and eigenvectors of a real matrix.\n<p>Computes the eigenvalues and eigenvectors of a matrix  …\n"],["Matrix::LUPDecomposition","","Matrix/LUPDecomposition.html","","<p>For an m-by-n matrix A with m &gt;= n, the LU decomposition is an m-by-n\nunit lower triangular matrix …\n"],["Vector","","Vector.html","","<p>The <code>Vector</code> class represents a mathematical vector, which is\nuseful in its own right, and also constitutes …\n"],["Vector::ZeroVectorError","","Vector/ZeroVectorError.html","",""],["*","Matrix","Matrix.html#method-i-2A","(m)","<p>Matrix multiplication.\n\n<pre>Matrix[[2,4], [6,8]] * Matrix.identity(2)\n  =&gt; 2 4\n     6 8</pre>\n"],["*","Vector","Vector.html#method-i-2A","(x)","<p>Multiplies the vector by <code>x</code>, where <code>x</code> is a number\nor another vector.\n"],["**","Matrix","Matrix.html#method-i-2A-2A","(other)","<p>Matrix exponentiation. Equivalent to multiplying the matrix by itself N\ntimes. Non integer exponents …\n"],["+","Matrix","Matrix.html#method-i-2B","(m)","<p>Matrix addition.\n\n<pre>Matrix.scalar(2,5) + Matrix[[1,0], [-4,7]]\n  =&gt;  6  0\n     -4 12</pre>\n"],["+","Vector","Vector.html#method-i-2B","(v)","<p>Vector addition.\n"],["+@","Matrix","Matrix.html#method-i-2B-40","()",""],["+@","Vector","Vector.html#method-i-2B-40","()",""],["-","Matrix","Matrix.html#method-i-2D","(m)","<p>Matrix subtraction.\n\n<pre>Matrix[[1,5], [4,2]] - Matrix[[9,3], [-4,1]]\n  =&gt; -8  2\n      8  1</pre>\n"],["-","Vector","Vector.html#method-i-2D","(v)","<p>Vector subtraction.\n"],["-@","Matrix","Matrix.html#method-i-2D-40","()",""],["-@","Vector","Vector.html#method-i-2D-40","()",""],["/","Matrix","Matrix.html#method-i-2F","(other)","<p>Matrix division (multiplication by the inverse).\n\n<pre>Matrix[[7,6], [3,9]] / Matrix[[2,9], [3,1]]\n  =&gt; -7  ...</pre>\n"],["/","Vector","Vector.html#method-i-2F","(x)","<p>Vector division.\n"],["==","Matrix","Matrix.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> if and only if the two matrices contain equal\nelements.\n"],["==","Vector","Vector.html#method-i-3D-3D","(other)","<p>Returns <code>true</code> iff the two vectors have the same elements in the\nsame order.\n"],["I","Matrix","Matrix.html#method-c-I","(n)",""],["[]","Matrix","Matrix.html#method-i-5B-5D","(i, j)","<p>Returns element (<code>i</code>,<code>j</code>) of the matrix.  That is:\nrow <code>i</code>, column <code>j</code>.\n"],["[]","Matrix","Matrix.html#method-c-5B-5D","(*rows)","<p>Creates a matrix where each argument is a row.\n\n<pre>Matrix[ [25, 93], [-1, 66] ]\n   =&gt;  25 93\n       -1 66</pre>\n"],["[]","Vector","Vector.html#method-c-5B-5D","(*array)","<p>Creates a Vector from a list of elements.\n\n<pre>Vector[7, 4, ...]</pre>\n"],["[]","Vector","Vector.html#method-i-5B-5D","(i)","<p>Returns element number <code>i</code> (starting at zero) of the vector.\n"],["adjugate","Matrix","Matrix.html#method-i-adjugate","()","<p>Returns the adjugate of the matrix.\n\n<pre>Matrix[ [7,6],[3,9] ].adjugate\n  =&gt; 9 -6\n     -3 7</pre>\n"],["angle_with","Vector","Vector.html#method-i-angle_with","(v)","<p>Returns an angle with another vector. Result is within the [0…Math::PI].\n\n<pre>Vector[1,0].angle_with(Vector[0,1]) ...</pre>\n"],["basis","Vector","Vector.html#method-c-basis","(size:, index:)","<p>Returns a standard basis <code>n</code>-vector, where k is the index.\n\n<pre>Vector.basis(size:, index:) # =&gt; Vector[0, 1, ...</pre>\n"],["build","Matrix","Matrix.html#method-c-build","(row_count, column_count = row_count)","<p>Creates a matrix of size <code>row_count</code> x\n<code>column_count</code>. It fills the values by calling the given block,\npassing …\n"],["clone","Matrix","Matrix.html#method-i-clone","()","<p>Returns a clone of the matrix, so that the contents of each do not\nreference identical objects. There …\n"],["clone","Vector","Vector.html#method-i-clone","()","<p>Returns a copy of the vector.\n"],["coerce","Matrix","Matrix.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion\nmechanism is used by Ruby to …\n"],["coerce","Vector","Vector.html#method-i-coerce","(other)","<p>The coerce method provides support for Ruby type coercion. This coercion\nmechanism is used by Ruby to …\n"],["cofactor","Matrix","Matrix.html#method-i-cofactor","(row, column)","<p>Returns the (row, column) cofactor which is obtained by multiplying the\nfirst minor by (-1)**(row + column). …\n"],["cofactor_expansion","Matrix","Matrix.html#method-i-cofactor_expansion","(row: nil, column: nil)",""],["collect","Matrix","Matrix.html#method-i-collect","()","<p>Returns a matrix that is the result of iteration of the given block over\nall elements of the matrix. …\n"],["collect","Vector","Vector.html#method-i-collect","()","<p>Like Array#collect.\n"],["collect2","Vector","Vector.html#method-i-collect2","(v)","<p>Collects (as in Enumerable#collect) over the elements of this vector and\n<code>v</code> in conjunction.\n"],["column","Matrix","Matrix.html#method-i-column","(j)","<p>Returns column vector number <code>j</code> of the matrix as a Vector\n(starting at 0 like an array).  When a block …\n"],["column_vector","Matrix","Matrix.html#method-c-column_vector","(column)","<p>Creates a single-column matrix where the values of that column are as given\nin <code>column</code>.\n\n<pre>Matrix.column_vector([4,5,6]) ...</pre>\n"],["column_vectors","Matrix","Matrix.html#method-i-column_vectors","()","<p>Returns an array of the column vectors of the matrix.  See Vector.\n"],["columns","Matrix","Matrix.html#method-c-columns","(columns)","<p>Creates a matrix using <code>columns</code> as an array of column vectors.\n\n<pre>Matrix.columns([[25, 93], [-1, 66]])\n   ...</pre>\n"],["component","Matrix","Matrix.html#method-i-component","(i, j)",""],["component","Vector","Vector.html#method-i-component","(i)",""],["conj","Matrix","Matrix.html#method-i-conj","()",""],["conjugate","Matrix","Matrix.html#method-i-conjugate","()","<p>Returns the conjugate of the matrix.\n\n<pre>Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n  =&gt; 1+2i   i ...</pre>\n"],["covector","Vector","Vector.html#method-i-covector","()","<p>Creates a single-row matrix from this vector.\n"],["cross","Vector","Vector.html#method-i-cross","(*vs)",""],["cross_product","Vector","Vector.html#method-i-cross_product","(*vs)","<p>Returns the cross product of this vector with the others.\n\n<pre>Vector[1, 0, 0].cross_product Vector[0, 1, 0] ...</pre>\n"],["d","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-d","()",""],["det","Matrix","Matrix.html#method-i-det","()",""],["det","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-det","()","<p>Returns the determinant of <code>A</code>, calculated efficiently from the\nfactorization.\n"],["det_e","Matrix","Matrix.html#method-i-det_e","()",""],["determinant","Matrix","Matrix.html#method-i-determinant","()","<p>Returns the determinant of the matrix.\n<p>Beware that using Float values can yield erroneous results because …\n"],["determinant","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-determinant","()",""],["determinant_e","Matrix","Matrix.html#method-i-determinant_e","()","<p>deprecated; use Matrix#determinant\n"],["diagonal","Matrix","Matrix.html#method-c-diagonal","(*values)","<p>Creates a matrix where the diagonal elements are composed of\n<code>values</code>.\n\n<pre>Matrix.diagonal(9, 5, -3)\n  =&gt;  9 ...</pre>\n"],["diagonal?","Matrix","Matrix.html#method-i-diagonal-3F","()","<p>Returns <code>true</code> if this is a diagonal matrix. Raises an error if\nmatrix is not square.\n"],["dot","Vector","Vector.html#method-i-dot","(v)",""],["each","Matrix","Matrix.html#method-i-each","(which = :all)","<p>Yields all elements of the matrix, starting with those of the first row, or\nreturns an Enumerator if …\n"],["each","Vector","Vector.html#method-i-each","(&block)","<p>Iterate over the elements of this vector\n"],["each2","Vector","Vector.html#method-i-each2","(v)","<p>Iterate over the elements of this vector and <code>v</code> in conjunction.\n"],["each_with_index","Matrix","Matrix.html#method-i-each_with_index","(which = :all)","<p>Same as #each, but the row index and column index in addition to the\nelement\n\n<pre>Matrix[ [1,2], [3,4] ].each_with_index ...</pre>\n"],["eigen","Matrix","Matrix.html#method-i-eigen","()",""],["eigensystem","Matrix","Matrix.html#method-i-eigensystem","()","<p>Returns the Eigensystem of the matrix; see\n<code>EigenvalueDecomposition</code>.\n\n<pre>m = Matrix[[1, 2], [3, 4]]\nv, d, v_inv ...</pre>\n"],["eigenvalue_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalue_matrix","()","<p>Returns the block diagonal eigenvalue matrix <code>D</code>\n"],["eigenvalues","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvalues","()","<p>Returns the eigenvalues in an array\n"],["eigenvector_matrix","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix","()","<p>Returns the eigenvector matrix <code>V</code>\n"],["eigenvector_matrix_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvector_matrix_inv","()","<p>Returns the inverse of the eigenvector matrix <code>V</code>\n"],["eigenvectors","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-eigenvectors","()","<p>Returns an array of the eigenvectors\n"],["element","Matrix","Matrix.html#method-i-element","(i, j)",""],["element","Vector","Vector.html#method-i-element","(i)",""],["elements","Vector","Vector.html#method-c-elements","(array, copy = true)","<p>Creates a vector from an Array.  The optional second argument specifies\nwhether the array itself or a …\n"],["elements_to_f","Matrix","Matrix.html#method-i-elements_to_f","()",""],["elements_to_f","Vector","Vector.html#method-i-elements_to_f","()",""],["elements_to_i","Matrix","Matrix.html#method-i-elements_to_i","()",""],["elements_to_i","Vector","Vector.html#method-i-elements_to_i","()",""],["elements_to_r","Matrix","Matrix.html#method-i-elements_to_r","()",""],["elements_to_r","Vector","Vector.html#method-i-elements_to_r","()",""],["empty","Matrix","Matrix.html#method-c-empty","(row_count = 0, column_count = 0)","<p>Creates a empty matrix of <code>row_count</code> x\n<code>column_count</code>. At least one of <code>row_count</code> or\n<code>column_count</code> must be …\n"],["empty?","Matrix","Matrix.html#method-i-empty-3F","()","<p>Returns <code>true</code> if this is an empty matrix, i.e. if the number of\nrows or the number of columns is 0.\n"],["eql?","Matrix","Matrix.html#method-i-eql-3F","(other)",""],["eql?","Vector","Vector.html#method-i-eql-3F","(other)",""],["find_index","Matrix","Matrix.html#method-i-find_index","(*args)",""],["first_minor","Matrix","Matrix.html#method-i-first_minor","(row, column)","<p>Returns the submatrix obtained by deleting the specified row and column.\n\n<pre>Matrix.diagonal(9, 5, -3, 4).first_minor(1, ...</pre>\n"],["hash","Matrix","Matrix.html#method-i-hash","()","<p>Returns a hash-code for the matrix.\n"],["hash","Vector","Vector.html#method-i-hash","()","<p>Returns a hash-code for the vector.\n"],["hermitian?","Matrix","Matrix.html#method-i-hermitian-3F","()","<p>Returns <code>true</code> if this is an hermitian matrix. Raises an error\nif matrix is not square.\n"],["hstack","Matrix","Matrix.html#method-i-hstack","(*matrices)","<p>Returns a new matrix resulting by stacking horizontally the receiver with\nthe given matrices\n\n<pre>x = Matrix[[1, ...</pre>\n"],["hstack","Matrix","Matrix.html#method-c-hstack","(x, *matrices)","<p>Create a matrix by stacking matrices horizontally\n\n<pre>x = Matrix[[1, 2], [3, 4]]\ny = Matrix[[5, 6], [7, 8]] ...</pre>\n"],["identity","Matrix","Matrix.html#method-c-identity","(n)","<p>Creates an <code>n</code> by <code>n</code> identity matrix.\n\n<pre>Matrix.identity(2)\n  =&gt; 1 0\n     0 1</pre>\n"],["imag","Matrix","Matrix.html#method-i-imag","()",""],["imaginary","Matrix","Matrix.html#method-i-imaginary","()","<p>Returns the imaginary part of the matrix.\n\n<pre>Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n  =&gt; 1+2i ...</pre>\n"],["independent?","Vector","Vector.html#method-i-independent-3F","(*vs)","<p>Returns <code>true</code> iff all of vectors are linearly independent.\n\n<pre>Vector[1,0].independent?(Vector[0,1])\n  =&gt; true ...</pre>\n"],["independent?","Vector","Vector.html#method-c-independent-3F","(*vs)","<p>Returns <code>true</code> iff all of vectors are linearly independent.\n\n<pre>Vector.independent?(Vector[1,0], Vector[0,1]) ...</pre>\n"],["index","Matrix","Matrix.html#method-i-index","(*args)","<p>The index method is specialized to return the index as [row, column] It\nalso accepts an optional <code>selector</code> …\n"],["inner_product","Vector","Vector.html#method-i-inner_product","(v)","<p>Returns the inner product of this vector with the other.\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">4</span>,<span class=\"ruby-value\">7</span>].<span class=\"ruby-identifier\">inner_product</span> <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">10</span>,<span class=\"ruby-value\">1</span>]  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-value\">47</span>\n</pre>\n"],["inspect","Matrix","Matrix.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inspect","Vector","Vector.html#method-i-inspect","()","<p>Overrides Object#inspect\n"],["inv","Matrix","Matrix.html#method-i-inv","()",""],["inverse","Matrix","Matrix.html#method-i-inverse","()","<p>Returns the inverse of the matrix.\n\n<pre>Matrix[[-1, -1], [0, -1]].inverse\n  =&gt; -1  1\n      0 -1</pre>\n"],["l","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-l","()",""],["laplace_expansion","Matrix","Matrix.html#method-i-laplace_expansion","(row: nil, column: nil)","<p>Returns the Laplace expansion along given row or column.\n\n<pre>Matrix[[7,6], [3,9]].laplace_expansion(column: ...</pre>\n"],["lower_triangular?","Matrix","Matrix.html#method-i-lower_triangular-3F","()","<p>Returns <code>true</code> if this is a lower triangular matrix.\n"],["lup","Matrix","Matrix.html#method-i-lup","()","<p>Returns the LUP decomposition of the matrix; see\n<code>LUPDecomposition</code>.\n\n<pre>a = Matrix[[1, 2], [3, 4]]\nl, u, p ...</pre>\n"],["lup_decomposition","Matrix","Matrix.html#method-i-lup_decomposition","()",""],["magnitude","Vector","Vector.html#method-i-magnitude","()","<p>Returns the modulus (Pythagorean distance) of the vector.\n\n<pre>Vector[5,8,2].r =&gt; 9.643650761</pre>\n"],["map","Matrix","Matrix.html#method-i-map","()",""],["map","Vector","Vector.html#method-i-map","()",""],["map2","Vector","Vector.html#method-i-map2","(v)","<p>Like Vector#collect2, but returns a Vector instead of an Array.\n"],["minor","Matrix","Matrix.html#method-i-minor","(*param)","<p>Returns a section of the matrix.  The parameters are either:\n<p>start_row, nrows, start_col, ncols; OR\n<p>row_range …\n"],["new","Matrix","Matrix.html#method-c-new","(rows, column_count = rows[0].size)","<p>Matrix.new is private; use Matrix.rows, columns, [], etc… to create.\n"],["new","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-c-new","(a)","<p>Constructs the eigenvalue decomposition for a square matrix <code>A</code>\n"],["new","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-c-new","(a)",""],["new","Vector","Vector.html#method-c-new","(array)","<p>Vector.new is private; use Vector[] or Vector.elements to create.\n"],["norm","Vector","Vector.html#method-i-norm","()",""],["normal?","Matrix","Matrix.html#method-i-normal-3F","()","<p>Returns <code>true</code> if this is a normal matrix. Raises an error if\nmatrix is not square.\n"],["normalize","Vector","Vector.html#method-i-normalize","()","<p>Returns a new vector with the same direction but with norm 1.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">v</span> = <span class=\"ruby-constant\">Vector</span>[<span class=\"ruby-value\">5</span>,<span class=\"ruby-value\">8</span>,<span class=\"ruby-value\">2</span>].<span class=\"ruby-identifier\">normalize</span>\n<span class=\"ruby-comment\"># =&gt; Vector[0.5184758473652127, ...</span>\n</pre>\n"],["orthogonal?","Matrix","Matrix.html#method-i-orthogonal-3F","()","<p>Returns <code>true</code> if this is an orthogonal matrix Raises an error\nif matrix is not square.\n"],["p","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-p","()","<p>Returns the permutation matrix <code>P</code>\n"],["permutation?","Matrix","Matrix.html#method-i-permutation-3F","()","<p>Returns <code>true</code> if this is a permutation matrix Raises an error\nif matrix is not square.\n"],["r","Vector","Vector.html#method-i-r","()",""],["rank","Matrix","Matrix.html#method-i-rank","()","<p>Returns the rank of the matrix. Beware that using Float values can yield\nerroneous results because of …\n"],["rank_e","Matrix","Matrix.html#method-i-rank_e","()","<p>deprecated; use Matrix#rank\n"],["real","Matrix","Matrix.html#method-i-real","()","<p>Returns the real part of the matrix.\n\n<pre>Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]\n  =&gt; 1+2i  i  ...</pre>\n"],["real?","Matrix","Matrix.html#method-i-real-3F","()","<p>Returns <code>true</code> if all entries of the matrix are real.\n"],["rect","Matrix","Matrix.html#method-i-rect","()","<p>Returns an array containing matrices corresponding to the real and\nimaginary parts of the matrix\n<p>m.rect …\n"],["rectangular","Matrix","Matrix.html#method-i-rectangular","()",""],["regular?","Matrix","Matrix.html#method-i-regular-3F","()","<p>Returns <code>true</code> if this is a regular (i.e. non-singular) matrix.\n"],["round","Matrix","Matrix.html#method-i-round","(ndigits=0)","<p>Returns a matrix with entries rounded to the given precision (see\nFloat#round)\n"],["row","Matrix","Matrix.html#method-i-row","(i)","<p>Returns row vector number <code>i</code> of the matrix as a Vector\n(starting at 0 like an array).  When a block is …\n"],["row_count","Matrix","Matrix.html#method-i-row_count","()","<p>Returns the number of rows.\n"],["row_size","Matrix","Matrix.html#method-i-row_size","()",""],["row_vector","Matrix","Matrix.html#method-c-row_vector","(row)","<p>Creates a single-row matrix where the values of that row are as given in\n<code>row</code>.\n\n<pre>Matrix.row_vector([4,5,6]) ...</pre>\n"],["row_vectors","Matrix","Matrix.html#method-i-row_vectors","()","<p>Returns an array of the row vectors of the matrix.  See Vector.\n"],["rows","Matrix","Matrix.html#method-c-rows","(rows, copy = true)","<p>Creates a matrix where <code>rows</code> is an array of arrays, each of\nwhich is a row of the matrix.  If the optional …\n"],["scalar","Matrix","Matrix.html#method-c-scalar","(n, value)","<p>Creates an <code>n</code> by <code>n</code> diagonal matrix where each\ndiagonal element is <code>value</code>.\n\n<pre>Matrix.scalar(2, 5)\n  =&gt; 5 0\n ...</pre>\n"],["singular?","Matrix","Matrix.html#method-i-singular-3F","()","<p>Returns <code>true</code> if this is a singular matrix.\n"],["singular?","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-singular-3F","()","<p>Returns <code>true</code> if <code>U</code>, and hence <code>A</code>, is\nsingular.\n"],["size","Vector","Vector.html#method-i-size","()","<p>Returns the number of elements in the vector.\n"],["solve","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-solve","(b)","<p>Returns <code>m</code> so that <code>A*m = b</code>, or equivalently so\nthat <code>L*U*m = P*b</code> <code>b</code> can be a Matrix or a Vector\n"],["square?","Matrix","Matrix.html#method-i-square-3F","()","<p>Returns <code>true</code> if this is a square matrix.\n"],["symmetric?","Matrix","Matrix.html#method-i-symmetric-3F","()","<p>Returns <code>true</code> if this is a symmetric matrix. Raises an error if\nmatrix is not square.\n"],["t","Matrix","Matrix.html#method-i-t","()",""],["to_a","Matrix","Matrix.html#method-i-to_a","()","<p>Returns an array of arrays that describe the rows of the matrix.\n"],["to_a","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_a","()",""],["to_a","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_a","()",""],["to_a","Vector","Vector.html#method-i-to_a","()","<p>Returns the elements of the vector in an array.\n"],["to_ary","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-to_ary","()","<p>Returns [eigenvector_matrix, eigenvalue_matrix, eigenvector_matrix_inv]\n"],["to_ary","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-to_ary","()","<p>Returns <code>L</code>, <code>U</code>, <code>P</code> in an array\n"],["to_s","Matrix","Matrix.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["to_s","Vector","Vector.html#method-i-to_s","()","<p>Overrides Object#to_s\n"],["tr","Matrix","Matrix.html#method-i-tr","()",""],["trace","Matrix","Matrix.html#method-i-trace","()","<p>Returns the trace (sum of diagonal elements) of the matrix.\n\n<pre>Matrix[[7,6], [3,9]].trace\n  =&gt; 16</pre>\n"],["transpose","Matrix","Matrix.html#method-i-transpose","()","<p>Returns the transpose of the matrix.\n\n<pre>Matrix[[1,2], [3,4], [5,6]]\n  =&gt; 1 2\n     3 4\n     5 6\nMatrix[[1,2], ...</pre>\n"],["u","Matrix::LUPDecomposition","Matrix/LUPDecomposition.html#method-i-u","()","<p>Returns the upper triangular factor <code>U</code>\n"],["unit","Matrix","Matrix.html#method-c-unit","(n)",""],["unitary?","Matrix","Matrix.html#method-i-unitary-3F","()","<p>Returns <code>true</code> if this is a unitary matrix Raises an error if\nmatrix is not square.\n"],["upper_triangular?","Matrix","Matrix.html#method-i-upper_triangular-3F","()","<p>Returns <code>true</code> if this is an upper triangular matrix.\n"],["v","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v","()",""],["v_inv","Matrix::EigenvalueDecomposition","Matrix/EigenvalueDecomposition.html#method-i-v_inv","()",""],["vstack","Matrix","Matrix.html#method-c-vstack","(x, *matrices)","<p>Create a matrix by stacking matrices vertically\n\n<pre>x = Matrix[[1, 2], [3, 4]]\ny = Matrix[[5, 6], [7, 8]] ...</pre>\n"],["vstack","Matrix","Matrix.html#method-i-vstack","(*matrices)","<p>Returns a new matrix resulting by stacking vertically the receiver with the\ngiven matrices\n\n<pre>x = Matrix[[1, ...</pre>\n"],["zero","Matrix","Matrix.html#method-c-zero","(row_count, column_count = row_count)","<p>Creates a zero matrix.\n\n<pre>Matrix.zero(2)\n  =&gt; 0 0\n     0 0</pre>\n"],["zero?","Matrix","Matrix.html#method-i-zero-3F","()","<p>Returns <code>true</code> if this is a matrix with only zero elements\n"]]}}
var search_data = {"index":{"searchIndex":["object","optparse","optparse","ac","acceptables","ambiguousargument","ambiguousoption","arguable","completinghash","completion","invalidargument","invalidoption","list","missingargument","needlessargument","optionmap","parseerror","regexp","switch","noargument","optionalargument","placedargument","requiredargument","abort()","abort()","ac_arg_disable()","ac_arg_enable()","ac_arg_with()","accept()","accept()","accept()","accept()","accept()","append()","banner()","banner()","base()","base()","candidate()","candidate()","candidate()","candidate()","complete()","complete()","convert()","def_head_option()","def_head_option()","def_option()","def_option()","def_tail_option()","def_tail_option()","define()","define()","define_head()","define_head()","define_tail()","define_tail()","each_const()","each_const()","each_option()","environment()","environment()","extend_object()","filter_backtrace()","getopts()","getopts()","getopts()","getopts()","getopts()","guess()","help()","help()","inc()","inc()","inc()","inc()","incompatible_argument_styles()","incompatible_argument_styles()","inspect()","load()","load()","make_switch()","make_switch()","match()","message()","new()","new()","new()","new()","new()","new()","new()","new()","on()","on()","on_head()","on_head()","on_tail()","on_tail()","options()","options=()","order()","order()","order!()","order!()","order!()","parse()","parse()","parse()","parse()","parse()","parse()","parse!()","parse!()","parse!()","pattern()","pattern()","permute()","permute()","permute!()","permute!()","permute!()","prepend()","program_name()","program_name()","reason()","recover()","regexp()","reject()","reject()","reject()","reject()","reject()","release()","release()","remove()","remove()","search()","search_const()","search_const()","separator()","separator()","set_backtrace()","set_option()","show_version()","show_version()","summarize()","summarize()","summarize()","summarize()","switch_name()","terminate()","terminate()","terminate()","terminate()","to_a()","to_a()","to_s()","to_s()","to_s()","top()","top()","top()","top()","ver()","ver()","version()","version()","warn()","warn()","with()","with()"],"longSearchIndex":["object","optparse","optionparser","optionparser::ac","optionparser::acceptables","optionparser::ambiguousargument","optionparser::ambiguousoption","optionparser::arguable","optionparser::completinghash","optionparser::completion","optionparser::invalidargument","optionparser::invalidoption","optionparser::list","optionparser::missingargument","optionparser::needlessargument","optionparser::optionmap","optionparser::parseerror","optionparser::regexp","optionparser::switch","optionparser::switch::noargument","optionparser::switch::optionalargument","optionparser::switch::placedargument","optionparser::switch::requiredargument","optionparser#abort()","optionparser#abort()","optionparser::ac#ac_arg_disable()","optionparser::ac#ac_arg_enable()","optionparser::ac#ac_arg_with()","optionparser::accept()","optionparser::accept()","optionparser#accept()","optionparser#accept()","optionparser::list#accept()","optionparser::list#append()","optionparser#banner()","optionparser#banner()","optionparser#base()","optionparser#base()","optionparser#candidate()","optionparser#candidate()","optionparser::completion#candidate()","optionparser::completion::candidate()","optionparser::completion#complete()","optionparser::list#complete()","optionparser::completion#convert()","optionparser#def_head_option()","optionparser#def_head_option()","optionparser#def_option()","optionparser#def_option()","optionparser#def_tail_option()","optionparser#def_tail_option()","optionparser#define()","optionparser#define()","optionparser#define_head()","optionparser#define_head()","optionparser#define_tail()","optionparser#define_tail()","optionparser::each_const()","optionparser::each_const()","optionparser::list#each_option()","optionparser#environment()","optionparser#environment()","optionparser::arguable::extend_object()","optionparser::parseerror::filter_backtrace()","optionparser#getopts()","optionparser::getopts()","optionparser::getopts()","optionparser#getopts()","optionparser::arguable#getopts()","optionparser::switch::guess()","optionparser#help()","optionparser#help()","optionparser#inc()","optionparser#inc()","optionparser::inc()","optionparser::inc()","optionparser::switch::incompatible_argument_styles()","optionparser::switch::noargument::incompatible_argument_styles()","optionparser::parseerror#inspect()","optionparser#load()","optionparser#load()","optionparser#make_switch()","optionparser#make_switch()","optionparser::completinghash#match()","optionparser::parseerror#message()","optionparser#new()","optionparser::new()","optionparser::new()","optionparser#new()","optionparser::arguable::new()","optionparser::list::new()","optionparser::parseerror::new()","optionparser::switch::new()","optionparser#on()","optionparser#on()","optionparser#on_head()","optionparser#on_head()","optionparser#on_tail()","optionparser#on_tail()","optionparser::arguable#options()","optionparser::arguable#options=()","optionparser#order()","optionparser#order()","optionparser#order!()","optionparser#order!()","optionparser::arguable#order!()","optionparser#parse()","optionparser#parse()","optionparser::switch::noargument#parse()","optionparser::switch::optionalargument#parse()","optionparser::switch::placedargument#parse()","optionparser::switch::requiredargument#parse()","optionparser#parse!()","optionparser#parse!()","optionparser::arguable#parse!()","optionparser::switch::pattern()","optionparser::switch::noargument::pattern()","optionparser#permute()","optionparser#permute()","optionparser#permute!()","optionparser#permute!()","optionparser::arguable#permute!()","optionparser::list#prepend()","optionparser#program_name()","optionparser#program_name()","optionparser::parseerror#reason()","optionparser::parseerror#recover()","optionparser::completion::regexp()","optionparser#reject()","optionparser::reject()","optionparser#reject()","optionparser::reject()","optionparser::list#reject()","optionparser#release()","optionparser#release()","optionparser#remove()","optionparser#remove()","optionparser::list#search()","optionparser::search_const()","optionparser::search_const()","optionparser#separator()","optionparser#separator()","optionparser::parseerror#set_backtrace()","optionparser::parseerror#set_option()","optionparser::show_version()","optionparser::show_version()","optionparser#summarize()","optionparser#summarize()","optionparser::list#summarize()","optionparser::switch#summarize()","optionparser::switch#switch_name()","optionparser::terminate()","optionparser::terminate()","optionparser#terminate()","optionparser#terminate()","optionparser#to_a()","optionparser#to_a()","optionparser#to_s()","optionparser#to_s()","optionparser::parseerror#to_s()","optionparser::top()","optionparser#top()","optionparser#top()","optionparser::top()","optionparser#ver()","optionparser#ver()","optionparser#version()","optionparser#version()","optionparser#warn()","optionparser#warn()","optionparser::with()","optionparser::with()"],"info":[["Object","","Object.html","",""],["OptParse","","OptParse.html","","<p>OptionParser\n<p>Introduction\n<p>OptionParser is a class for command-line option analysis.  It is much more\nadvanced, …\n"],["OptionParser","","OptionParser.html","","<p>OptionParser\n<p>Introduction\n<p>OptionParser is a class for command-line option analysis.  It is much more\nadvanced, …\n"],["OptionParser::AC","","OptionParser/AC.html","",""],["OptionParser::Acceptables","","OptionParser/Acceptables.html","","<p>Acceptable argument classes. Now contains DecimalInteger, OctalInteger and\nDecimalNumeric. See Acceptable …\n"],["OptionParser::AmbiguousArgument","","OptionParser/AmbiguousArgument.html","","<p>Raises when the given argument word can’t be completed uniquely.\n"],["OptionParser::AmbiguousOption","","OptionParser/AmbiguousOption.html","","<p>Raises when ambiguously completable string is encountered.\n"],["OptionParser::Arguable","","OptionParser/Arguable.html","","<p>Extends command line arguments array (ARGV) to parse itself.\n"],["OptionParser::CompletingHash","","OptionParser/CompletingHash.html","","<p>Hash with completion search feature. See OptionParser::Completion.\n"],["OptionParser::Completion","","OptionParser/Completion.html","","<p>Keyword completion module.  This allows partial arguments to be specified\nand resolved against a list …\n"],["OptionParser::InvalidArgument","","OptionParser/InvalidArgument.html","","<p>Raises when the given argument does not match required format.\n"],["OptionParser::InvalidOption","","OptionParser/InvalidOption.html","","<p>Raises when switch is undefined.\n"],["OptionParser::List","","OptionParser/List.html","","<p>Simple option list providing mapping from short and/or long option string\nto OptionParser::Switch and …\n"],["OptionParser::MissingArgument","","OptionParser/MissingArgument.html","","<p>Raises when a switch with mandatory argument has no argument.\n"],["OptionParser::NeedlessArgument","","OptionParser/NeedlessArgument.html","","<p>Raises when there is an argument for a switch which takes no argument.\n"],["OptionParser::OptionMap","","OptionParser/OptionMap.html","","<p>Map from option/keyword string to object with completion.\n"],["OptionParser::ParseError","","OptionParser/ParseError.html","","<p>Base class of exceptions from OptionParser.\n"],["OptionParser::Regexp","","OptionParser/Regexp.html","",""],["OptionParser::Switch","","OptionParser/Switch.html","","<p>Individual switch class.  Not important to the user.\n<p>Defined within Switch are several Switch-derived …\n"],["OptionParser::Switch::NoArgument","","OptionParser/Switch/NoArgument.html","","<p>Switch that takes no arguments.\n"],["OptionParser::Switch::OptionalArgument","","OptionParser/Switch/OptionalArgument.html","","<p>Switch that can omit argument.\n"],["OptionParser::Switch::PlacedArgument","","OptionParser/Switch/PlacedArgument.html","","<p>Switch that takes an argument, which does not begin with ‘-’.\n"],["OptionParser::Switch::RequiredArgument","","OptionParser/Switch/RequiredArgument.html","","<p>Switch that takes an argument.\n"],["abort","OptionParser","OptionParser.html#method-i-abort","(mesg = $!)",""],["abort","OptionParser","OptionParser.html#method-i-abort","(mesg = $!)",""],["ac_arg_disable","OptionParser::AC","OptionParser/AC.html#method-i-ac_arg_disable","(name, help_string, &block)",""],["ac_arg_enable","OptionParser::AC","OptionParser/AC.html#method-i-ac_arg_enable","(name, help_string, &block)",""],["ac_arg_with","OptionParser::AC","OptionParser/AC.html#method-i-ac_arg_with","(name, help_string, &block)",""],["accept","OptionParser","OptionParser.html#method-c-accept","(*args, &blk)","<p>See #accept.\n"],["accept","OptionParser","OptionParser.html#method-c-accept","(*args, &blk)","<p>See #accept.\n"],["accept","OptionParser","OptionParser.html#method-i-accept","(*args, &blk)","<p>Directs to accept specified class <code>t</code>. The argument string is\npassed to the block in which it should be …\n"],["accept","OptionParser","OptionParser.html#method-i-accept","(*args, &blk)","<p>Directs to accept specified class <code>t</code>. The argument string is\npassed to the block in which it should be …\n"],["accept","OptionParser::List","OptionParser/List.html#method-i-accept","(t, pat = /.*/m, &block)","<p>See OptionParser.accept.\n"],["append","OptionParser::List","OptionParser/List.html#method-i-append","(*args)","<p>Appends <code>switch</code> at the tail of the list, and associates short,\nlong and negated long options. Arguments …\n"],["banner","OptionParser","OptionParser.html#method-i-banner","()","<p>Heading banner preceding summary.\n"],["banner","OptionParser","OptionParser.html#method-i-banner","()","<p>Heading banner preceding summary.\n"],["base","OptionParser","OptionParser.html#method-i-base","()","<p>Subject of #on_tail.\n"],["base","OptionParser","OptionParser.html#method-i-base","()","<p>Subject of #on_tail.\n"],["candidate","OptionParser","OptionParser.html#method-i-candidate","(word)",""],["candidate","OptionParser","OptionParser.html#method-i-candidate","(word)",""],["candidate","OptionParser::Completion","OptionParser/Completion.html#method-i-candidate","(key, icase = false, pat = nil)",""],["candidate","OptionParser::Completion","OptionParser/Completion.html#method-c-candidate","(key, icase = false, pat = nil, &block)",""],["complete","OptionParser::Completion","OptionParser/Completion.html#method-i-complete","(key, icase = false, pat = nil)",""],["complete","OptionParser::List","OptionParser/List.html#method-i-complete","(id, opt, icase = false, *pat, &block)","<p>Searches list <code>id</code> for <code>opt</code> and the optional\npatterns for completion <code>pat</code>. If <code>icase</code> is true,\nthe search is …\n"],["convert","OptionParser::Completion","OptionParser/Completion.html#method-i-convert","(opt = nil, val = nil, *)",""],["def_head_option","OptionParser","OptionParser.html#method-i-def_head_option","(*opts, &block)",""],["def_head_option","OptionParser","OptionParser.html#method-i-def_head_option","(*opts, &block)",""],["def_option","OptionParser","OptionParser.html#method-i-def_option","(*opts, &block)",""],["def_option","OptionParser","OptionParser.html#method-i-def_option","(*opts, &block)",""],["def_tail_option","OptionParser","OptionParser.html#method-i-def_tail_option","(*opts, &block)",""],["def_tail_option","OptionParser","OptionParser.html#method-i-def_tail_option","(*opts, &block)",""],["define","OptionParser","OptionParser.html#method-i-define","(*opts, &block)",""],["define","OptionParser","OptionParser.html#method-i-define","(*opts, &block)",""],["define_head","OptionParser","OptionParser.html#method-i-define_head","(*opts, &block)",""],["define_head","OptionParser","OptionParser.html#method-i-define_head","(*opts, &block)",""],["define_tail","OptionParser","OptionParser.html#method-i-define_tail","(*opts, &block)",""],["define_tail","OptionParser","OptionParser.html#method-i-define_tail","(*opts, &block)",""],["each_const","OptionParser","OptionParser.html#method-c-each_const","(path, base = ::Object)",""],["each_const","OptionParser","OptionParser.html#method-c-each_const","(path, base = ::Object)",""],["each_option","OptionParser::List","OptionParser/List.html#method-i-each_option","(&block)","<p>Iterates over each option, passing the option to the <code>block</code>.\n"],["environment","OptionParser","OptionParser.html#method-i-environment","(env = File.basename($0, '.*'))","<p>Parses environment variable <code>env</code> or its uppercase with\nsplitting like a shell.\n<p><code>env</code> defaults to the basename ...\n"],["environment","OptionParser","OptionParser.html#method-i-environment","(env = File.basename($0, '.*'))","<p>Parses environment variable <code>env</code> or its uppercase with\nsplitting like a shell.\n<p><code>env</code> defaults to the basename ...\n"],["extend_object","OptionParser::Arguable","OptionParser/Arguable.html#method-c-extend_object","(obj)","<p>Initializes instance variable.\n"],["filter_backtrace","OptionParser::ParseError","OptionParser/ParseError.html#method-c-filter_backtrace","(array)",""],["getopts","OptionParser","OptionParser.html#method-i-getopts","(*args)","<p>Wrapper method for getopts.rb.\n\n<pre>params = ARGV.getopts(&quot;ab:&quot;, &quot;foo&quot;, &quot;bar:&quot;, &quot;zot:Z;zot option)\n# params[:a] ...</pre>\n"],["getopts","OptionParser","OptionParser.html#method-c-getopts","(*args)","<p>See #getopts.\n"],["getopts","OptionParser","OptionParser.html#method-c-getopts","(*args)","<p>See #getopts.\n"],["getopts","OptionParser","OptionParser.html#method-i-getopts","(*args)","<p>Wrapper method for getopts.rb.\n\n<pre>params = ARGV.getopts(&quot;ab:&quot;, &quot;foo&quot;, &quot;bar:&quot;, &quot;zot:Z;zot option)\n# params[:a] ...</pre>\n"],["getopts","OptionParser::Arguable","OptionParser/Arguable.html#method-i-getopts","(*args)","<p>Substitution of getopts is possible as follows. Also see\nOptionParser#getopts.\n\n<pre>def getopts(*args)\n  ($OPT ...</pre>\n"],["guess","OptionParser::Switch","OptionParser/Switch.html#method-c-guess","(arg)","<p>Guesses argument style from <code>arg</code>.  Returns corresponding\nOptionParser::Switch class (OptionalArgument, …\n"],["help","OptionParser","OptionParser.html#method-i-help","()","<p>Returns option summary string.\n"],["help","OptionParser","OptionParser.html#method-i-help","()","<p>Returns option summary string.\n"],["inc","OptionParser","OptionParser.html#method-i-inc","(*args)",""],["inc","OptionParser","OptionParser.html#method-i-inc","(*args)",""],["inc","OptionParser","OptionParser.html#method-c-inc","(arg, default = nil)","<p>Returns an incremented value of <code>default</code> according to\n<code>arg</code>.\n"],["inc","OptionParser","OptionParser.html#method-c-inc","(arg, default = nil)","<p>Returns an incremented value of <code>default</code> according to\n<code>arg</code>.\n"],["incompatible_argument_styles","OptionParser::Switch","OptionParser/Switch.html#method-c-incompatible_argument_styles","(arg, t)",""],["incompatible_argument_styles","OptionParser::Switch::NoArgument","OptionParser/Switch/NoArgument.html#method-c-incompatible_argument_styles","(*)",""],["inspect","OptionParser::ParseError","OptionParser/ParseError.html#method-i-inspect","()",""],["load","OptionParser","OptionParser.html#method-i-load","(filename = nil)","<p>Loads options from file names as <code>filename</code>. Does nothing when\nthe file is not present. Returns whether …\n"],["load","OptionParser","OptionParser.html#method-i-load","(filename = nil)","<p>Loads options from file names as <code>filename</code>. Does nothing when\nthe file is not present. Returns whether …\n"],["make_switch","OptionParser","OptionParser.html#method-i-make_switch","(opts, block = nil)","<p>Creates an OptionParser::Switch from the parameters. The parsed argument\nvalue is passed to the given …\n"],["make_switch","OptionParser","OptionParser.html#method-i-make_switch","(opts, block = nil)","<p>Creates an OptionParser::Switch from the parameters. The parsed argument\nvalue is passed to the given …\n"],["match","OptionParser::CompletingHash","OptionParser/CompletingHash.html#method-i-match","(key)","<p>Completion for hash key.\n"],["message","OptionParser::ParseError","OptionParser/ParseError.html#method-i-message","()","<p>Default stringizing method to emit standard error message.\n"],["new","OptionParser","OptionParser.html#method-i-new","()","<p>Pushes a new List.\n"],["new","OptionParser","OptionParser.html#method-c-new","(banner = nil, width = 32, indent = ' ' * 4)","<p>Initializes the instance and yields itself if called with a block.\n<p>banner &mdash; Banner message.\n<p>width &mdash; Summary …\n"],["new","OptionParser","OptionParser.html#method-c-new","(banner = nil, width = 32, indent = ' ' * 4)","<p>Initializes the instance and yields itself if called with a block.\n<p>banner &mdash; Banner message.\n<p>width &mdash; Summary …\n"],["new","OptionParser","OptionParser.html#method-i-new","()","<p>Pushes a new List.\n"],["new","OptionParser::Arguable","OptionParser/Arguable.html#method-c-new","(*args)",""],["new","OptionParser::List","OptionParser/List.html#method-c-new","()","<p>Just initializes all instance variables.\n"],["new","OptionParser::ParseError","OptionParser/ParseError.html#method-c-new","(*args)",""],["new","OptionParser::Switch","OptionParser/Switch.html#method-c-new","(pattern = nil, conv = nil, short = nil, long = nil, arg = nil, desc = ([] if short or long), block = Proc.new)",""],["on","OptionParser","OptionParser.html#method-i-on","(*opts, &block)","<p>Add option switch and handler. See #make_switch for an explanation of\nparameters.\n"],["on","OptionParser","OptionParser.html#method-i-on","(*opts, &block)","<p>Add option switch and handler. See #make_switch for an explanation of\nparameters.\n"],["on_head","OptionParser","OptionParser.html#method-i-on_head","(*opts, &block)","<p>Add option switch like with #on, but at head of summary.\n"],["on_head","OptionParser","OptionParser.html#method-i-on_head","(*opts, &block)","<p>Add option switch like with #on, but at head of summary.\n"],["on_tail","OptionParser","OptionParser.html#method-i-on_tail","(*opts, &block)","<p>Add option switch like with #on, but at tail of summary.\n"],["on_tail","OptionParser","OptionParser.html#method-i-on_tail","(*opts, &block)","<p>Add option switch like with #on, but at tail of summary.\n"],["options","OptionParser::Arguable","OptionParser/Arguable.html#method-i-options","()","<p>Actual OptionParser object, automatically created if nonexistent.\n<p>If called with a block, yields the  …\n"],["options=","OptionParser::Arguable","OptionParser/Arguable.html#method-i-options-3D","(opt)","<p>Sets OptionParser object, when <code>opt</code> is <code>false</code> or\n<code>nil</code>, methods OptionParser::Arguable#options and\nOptionParser::Arguable#options= …\n"],["order","OptionParser","OptionParser.html#method-i-order","(*argv, &block)","<p>Parses command line arguments <code>argv</code> in order. When a block is\ngiven, each non-option argument is yielded. …\n"],["order","OptionParser","OptionParser.html#method-i-order","(*argv, &block)","<p>Parses command line arguments <code>argv</code> in order. When a block is\ngiven, each non-option argument is yielded. …\n"],["order!","OptionParser","OptionParser.html#method-i-order-21","(argv = default_argv, &nonopt)","<p>Same as #order, but removes switches destructively. Non-option arguments\nremain in <code>argv</code>.\n"],["order!","OptionParser","OptionParser.html#method-i-order-21","(argv = default_argv, &nonopt)","<p>Same as #order, but removes switches destructively. Non-option arguments\nremain in <code>argv</code>.\n"],["order!","OptionParser::Arguable","OptionParser/Arguable.html#method-i-order-21","(&blk)","<p>Parses <code>self</code> destructively in order and returns\n<code>self</code> containing the rest arguments left unparsed.\n"],["parse","OptionParser","OptionParser.html#method-i-parse","(*argv)","<p>Parses command line arguments <code>argv</code> in order when environment\nvariable POSIXLY_CORRECT is set, and in …\n"],["parse","OptionParser","OptionParser.html#method-i-parse","(*argv)","<p>Parses command line arguments <code>argv</code> in order when environment\nvariable POSIXLY_CORRECT is set, and in …\n"],["parse","OptionParser::Switch::NoArgument","OptionParser/Switch/NoArgument.html#method-i-parse","(arg, argv)","<p>Raises an exception if any arguments given.\n"],["parse","OptionParser::Switch::OptionalArgument","OptionParser/Switch/OptionalArgument.html#method-i-parse","(arg, argv, &error)","<p>Parses argument if given, or uses default value.\n"],["parse","OptionParser::Switch::PlacedArgument","OptionParser/Switch/PlacedArgument.html#method-i-parse","(arg, argv, &error)","<p>Returns nil if argument is not present or begins with ‘-’.\n"],["parse","OptionParser::Switch::RequiredArgument","OptionParser/Switch/RequiredArgument.html#method-i-parse","(arg, argv)","<p>Raises an exception if argument is not present.\n"],["parse!","OptionParser","OptionParser.html#method-i-parse-21","(argv = default_argv)","<p>Same as #parse, but removes switches destructively. Non-option arguments\nremain in <code>argv</code>.\n"],["parse!","OptionParser","OptionParser.html#method-i-parse-21","(argv = default_argv)","<p>Same as #parse, but removes switches destructively. Non-option arguments\nremain in <code>argv</code>.\n"],["parse!","OptionParser::Arguable","OptionParser/Arguable.html#method-i-parse-21","()","<p>Parses <code>self</code> destructively and returns <code>self</code>\ncontaining the rest arguments left unparsed.\n"],["pattern","OptionParser::Switch","OptionParser/Switch.html#method-c-pattern","()",""],["pattern","OptionParser::Switch::NoArgument","OptionParser/Switch/NoArgument.html#method-c-pattern","()",""],["permute","OptionParser","OptionParser.html#method-i-permute","(*argv)","<p>Parses command line arguments <code>argv</code> in permutation mode and\nreturns list of non-option arguments.\n"],["permute","OptionParser","OptionParser.html#method-i-permute","(*argv)","<p>Parses command line arguments <code>argv</code> in permutation mode and\nreturns list of non-option arguments.\n"],["permute!","OptionParser","OptionParser.html#method-i-permute-21","(argv = default_argv)","<p>Same as #permute, but removes switches destructively. Non-option arguments\nremain in <code>argv</code>.\n"],["permute!","OptionParser","OptionParser.html#method-i-permute-21","(argv = default_argv)","<p>Same as #permute, but removes switches destructively. Non-option arguments\nremain in <code>argv</code>.\n"],["permute!","OptionParser::Arguable","OptionParser/Arguable.html#method-i-permute-21","()","<p>Parses <code>self</code> destructively in permutation mode and returns\n<code>self</code> containing the rest arguments left unparsed. …\n"],["prepend","OptionParser::List","OptionParser/List.html#method-i-prepend","(*args)","<p>Inserts <code>switch</code> at the head of the list, and associates short,\nlong and negated long options. Arguments …\n"],["program_name","OptionParser","OptionParser.html#method-i-program_name","()","<p>Program name to be emitted in error message and default banner, defaults to\n$0.\n"],["program_name","OptionParser","OptionParser.html#method-i-program_name","()","<p>Program name to be emitted in error message and default banner, defaults to\n$0.\n"],["reason","OptionParser::ParseError","OptionParser/ParseError.html#method-i-reason","()","<p>Returns error reason. Override this for I18N.\n"],["recover","OptionParser::ParseError","OptionParser/ParseError.html#method-i-recover","(argv)","<p>Pushes back erred argument(s) to <code>argv</code>.\n"],["regexp","OptionParser::Completion","OptionParser/Completion.html#method-c-regexp","(key, icase)",""],["reject","OptionParser","OptionParser.html#method-i-reject","(*args, &blk)","<p>Directs to reject specified class argument.\n<p>t &mdash; Argument class specifier, any object including Class.\n\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">reject</span>(<span class=\"ruby-identifier\">t</span>)\n</pre>\n"],["reject","OptionParser","OptionParser.html#method-c-reject","(*args, &blk)","<p>See #reject.\n"],["reject","OptionParser","OptionParser.html#method-i-reject","(*args, &blk)","<p>Directs to reject specified class argument.\n<p>t &mdash; Argument class specifier, any object including Class.\n\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">reject</span>(<span class=\"ruby-identifier\">t</span>)\n</pre>\n"],["reject","OptionParser","OptionParser.html#method-c-reject","(*args, &blk)","<p>See #reject.\n"],["reject","OptionParser::List","OptionParser/List.html#method-i-reject","(t)","<p>See OptionParser.reject.\n"],["release","OptionParser","OptionParser.html#method-i-release","()","<p>Release code\n"],["release","OptionParser","OptionParser.html#method-i-release","()","<p>Release code\n"],["remove","OptionParser","OptionParser.html#method-i-remove","()","<p>Removes the last List.\n"],["remove","OptionParser","OptionParser.html#method-i-remove","()","<p>Removes the last List.\n"],["search","OptionParser::List","OptionParser/List.html#method-i-search","(id, key)","<p>Searches <code>key</code> in <code>id</code> list. The result is returned\nor yielded if a block is given. If it isn’t found, nil …\n"],["search_const","OptionParser","OptionParser.html#method-c-search_const","(klass, name)",""],["search_const","OptionParser","OptionParser.html#method-c-search_const","(klass, name)",""],["separator","OptionParser","OptionParser.html#method-i-separator","(string)","<p>Add separator in summary.\n"],["separator","OptionParser","OptionParser.html#method-i-separator","(string)","<p>Add separator in summary.\n"],["set_backtrace","OptionParser::ParseError","OptionParser/ParseError.html#method-i-set_backtrace","(array)",""],["set_option","OptionParser::ParseError","OptionParser/ParseError.html#method-i-set_option","(opt, eq)",""],["show_version","OptionParser","OptionParser.html#method-c-show_version","(*pkgs)",""],["show_version","OptionParser","OptionParser.html#method-c-show_version","(*pkgs)",""],["summarize","OptionParser","OptionParser.html#method-i-summarize","(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)","<p>Puts option summary into <code>to</code> and returns <code>to</code>.\nYields each line if a block is given.\n<p>to &mdash; Output destination, …\n"],["summarize","OptionParser","OptionParser.html#method-i-summarize","(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &blk)","<p>Puts option summary into <code>to</code> and returns <code>to</code>.\nYields each line if a block is given.\n<p>to &mdash; Output destination, …\n"],["summarize","OptionParser::List","OptionParser/List.html#method-i-summarize","(*args, &block)","<p>Creates the summary table, passing each line to the <code>block</code>\n(without newline). The arguments <code>args</code> are passed …\n"],["summarize","OptionParser::Switch","OptionParser/Switch.html#method-i-summarize","(sdone = [], ldone = [], width = 1, max = width - 1, indent = \"\")","<p>Produces the summary text. Each line of the summary is yielded to the block\n(without newline).\n<p>sdone &mdash; "],["switch_name","OptionParser::Switch","OptionParser/Switch.html#method-i-switch_name","()","<p>Main name of the switch.\n"],["terminate","OptionParser","OptionParser.html#method-c-terminate","(arg = nil)",""],["terminate","OptionParser","OptionParser.html#method-c-terminate","(arg = nil)",""],["terminate","OptionParser","OptionParser.html#method-i-terminate","(arg = nil)","<p>Terminates option parsing. Optional parameter <code>arg</code> is a string\npushed back to be the first non-option …\n"],["terminate","OptionParser","OptionParser.html#method-i-terminate","(arg = nil)","<p>Terminates option parsing. Optional parameter <code>arg</code> is a string\npushed back to be the first non-option …\n"],["to_a","OptionParser","OptionParser.html#method-i-to_a","()","<p>Returns option summary list.\n"],["to_a","OptionParser","OptionParser.html#method-i-to_a","()","<p>Returns option summary list.\n"],["to_s","OptionParser","OptionParser.html#method-i-to_s","()",""],["to_s","OptionParser","OptionParser.html#method-i-to_s","()",""],["to_s","OptionParser::ParseError","OptionParser/ParseError.html#method-i-to_s","()",""],["top","OptionParser","OptionParser.html#method-c-top","()",""],["top","OptionParser","OptionParser.html#method-i-top","()","<p>Subject of #on / #on_head, #accept / #reject\n"],["top","OptionParser","OptionParser.html#method-i-top","()","<p>Subject of #on / #on_head, #accept / #reject\n"],["top","OptionParser","OptionParser.html#method-c-top","()",""],["ver","OptionParser","OptionParser.html#method-i-ver","()","<p>Returns version string from program_name, version and release.\n"],["ver","OptionParser","OptionParser.html#method-i-ver","()","<p>Returns version string from program_name, version and release.\n"],["version","OptionParser","OptionParser.html#method-i-version","()","<p>Version\n"],["version","OptionParser","OptionParser.html#method-i-version","()","<p>Version\n"],["warn","OptionParser","OptionParser.html#method-i-warn","(mesg = $!)",""],["warn","OptionParser","OptionParser.html#method-i-warn","(mesg = $!)",""],["with","OptionParser","OptionParser.html#method-c-with","(*args, &block)","<p>Initializes a new instance and evaluates the optional block in context of\nthe instance. Arguments <code>args</code> …\n"],["with","OptionParser","OptionParser.html#method-c-with","(*args, &block)","<p>Initializes a new instance and evaluates the optional block in context of\nthe instance. Arguments <code>args</code> …\n"]]}}
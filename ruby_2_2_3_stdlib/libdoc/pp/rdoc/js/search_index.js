var search_data = {"index":{"searchIndex":["kernel","pp","ppmethods","check_inspect_key()","comma_breakable()","guard_inspect_key()","object_address_group()","object_group()","pop_inspect_key()","pp()","pp()","pp_hash()","pp_object()","pretty_inspect()","push_inspect_key()","seplist()","singleline_pp()"],"longSearchIndex":["kernel","pp","pp::ppmethods","pp::ppmethods#check_inspect_key()","pp::ppmethods#comma_breakable()","pp::ppmethods#guard_inspect_key()","pp::ppmethods#object_address_group()","pp::ppmethods#object_group()","pp::ppmethods#pop_inspect_key()","pp::pp()","pp::ppmethods#pp()","pp::ppmethods#pp_hash()","pp::ppmethods#pp_object()","kernel#pretty_inspect()","pp::ppmethods#push_inspect_key()","pp::ppmethods#seplist()","pp::singleline_pp()"],"info":[["Kernel","","Kernel.html","",""],["PP","","PP.html","","<p>A pretty-printer for Ruby objects.\n<p>All examples assume you have loaded the PP class with:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">require</span> <span class=\"ruby-string\">'pp'</span>\n</pre>\n"],["PP::PPMethods","","PP/PPMethods.html","",""],["check_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-check_inspect_key","(id)","<p>Check whether the object_id <code>id</code> is in the current buffer of\nobjects to be pretty printed. Used to break …\n"],["comma_breakable","PP::PPMethods","PP/PPMethods.html#method-i-comma_breakable","()","<p>A convenience method which is same as follows:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">text</span> <span class=\"ruby-string\">','</span>\n<span class=\"ruby-identifier\">breakable</span>\n</pre>\n"],["guard_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-guard_inspect_key","()","<p>Yields to a block and preserves the previous set of objects being printed.\n"],["object_address_group","PP::PPMethods","PP/PPMethods.html#method-i-object_address_group","(obj, &block)","<p>A convenience method, like object_group, but also reformats the Object’s\nobject_id.\n"],["object_group","PP::PPMethods","PP/PPMethods.html#method-i-object_group","(obj)","<p>A convenience method which is same as follows:\n\n<pre>group(1, '#&lt;' + obj.class.name, '&gt;') { ... }</pre>\n"],["pop_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-pop_inspect_key","(id)","<p>Removes an object from the set of objects being pretty printed.\n"],["pp","PP","PP.html#method-c-pp","(obj, out=$>, width=79)","<p>Outputs <code>obj</code> to <code>out</code> in pretty printed format of\n<code>width</code> columns in width.\n<p>If <code>out</code> is omitted, <code>$&gt;</code> is assumed. …\n"],["pp","PP::PPMethods","PP/PPMethods.html#method-i-pp","(obj)","<p>Adds <code>obj</code> to the pretty printing buffer using\nObject#pretty_print or Object#pretty_print_cycle.\n<p>Object#pretty_print_cycle …\n"],["pp_hash","PP::PPMethods","PP/PPMethods.html#method-i-pp_hash","(obj)","<p>A pretty print for a Hash\n"],["pp_object","PP::PPMethods","PP/PPMethods.html#method-i-pp_object","(obj)","<p>A present standard failsafe for pretty printing any given Object\n"],["pretty_inspect","Kernel","Kernel.html#method-i-pretty_inspect","()","<p>Returns a pretty printed object as a string.\n<p>In order to use this method you must first require the PP …\n"],["push_inspect_key","PP::PPMethods","PP/PPMethods.html#method-i-push_inspect_key","(id)","<p>Adds the object_id <code>id</code> to the set of objects being pretty\nprinted, so as to not repeat objects.\n"],["seplist","PP::PPMethods","PP/PPMethods.html#method-i-seplist","(list, sep=nil, iter_method=:each)","<p>Adds a separated list. The list is separated by comma with breakable space,\nby default.\n<p>#seplist iterates …\n"],["singleline_pp","PP","PP.html#method-c-singleline_pp","(obj, out=$>)","<p>Outputs <code>obj</code> to <code>out</code> like PP.pp but with no indent\nand newline.\n<p>PP.singleline_pp returns <code>out</code>.\n"]]}}